// Auto-generated by scripts/build-blog.ts
// Do not edit manually - edit the markdown files in /website/blog/ instead

export const blogIndex = [
  {
    "slug": "seo-pages-cloudflare-workers-routing",
    "title": "Adding SEO Pages to a CloudFlare Pages SPA: The Routing Sequel",
    "date": "2026-02-17",
    "description": "After solving SPA routing on CloudFlare Pages, we needed to add server-rendered and static pages alongside the SPA. New platform, new surprises — 308 redirects, stale workers, build pipeline ordering, and the art of making static and dynamic content coexist."
  },
  {
    "slug": "svg-serialization-trap",
    "title": "The SVG Serialization Trap: Why createElementNS Broke Our Thumbnail Pipeline",
    "date": "2026-02-11",
    "description": "How programmatically created SVG elements silently produce broken output when serialized with XMLSerializer and loaded as images — and the surprisingly simple fix."
  },
  {
    "slug": "cloudflare-pages-spa-routing-struggle",
    "title": "The CloudFlare Pages SPA Routing Odyssey",
    "date": "2026-01-28",
    "description": "A developer's journey through documentation gaps when trying to make SPA routing work on CloudFlare Pages with subdirectory deployments."
  }
];

export const posts = {
  'cloudflare-pages-spa-routing-struggle': `<h1>The CloudFlare Pages SPA Routing Odyssey: A Developer&#39;s Journey Through Documentation Gaps</h1>
<h2>The Problem</h2>
<p>What should have been a simple task—making a Single Page Application work with direct URL navigation on CloudFlare Pages—turned into a multi-hour debugging session that exposed significant gaps in CloudFlare&#39;s documentation and inconsistencies between their local development tools and production behavior.</p>
<p>The issue was straightforward: our SPA lived at <code>/svg-path-extended/</code> with client-side routes like <code>/svg-path-extended/docs</code>, <code>/svg-path-extended/preferences</code>, and <code>/svg-path-extended/workspace/new</code>. Navigating to these routes from within the app worked fine. But typing a URL directly into the browser or refreshing the page? That&#39;s where things fell apart.</p>
<ul>
<li><strong>Locally with <code>wrangler pages dev</code></strong>: Routes returned 404 errors or 307/308 redirects to the base path</li>
<li><strong>On CloudFlare Pages production</strong>: Routes redirected to <code>/svg-path-extended/</code> instead of serving the SPA</li>
</ul>
<p>Both behaviors meant the same thing: the SPA&#39;s client-side router never got a chance to handle the URL.</p>
<h2>The First Attempt: <code>_redirects</code> File</h2>
<p>CloudFlare Pages documentation prominently features the <code>_redirects</code> file as the solution for SPA routing. The syntax seems simple enough:</p>
<pre><code class="hljs">/svg-path-extended/docs  /svg-path-extended/index.html  200
/svg-path-extended/preferences  /svg-path-extended/index.html  200
/svg-path-extended/*  /svg-path-extended/index.html  200
</code></pre><p>The <code>200</code> status code is supposed to perform a &quot;rewrite&quot;—serve the content of <code>index.html</code> while preserving the URL in the browser. This is exactly what SPAs need.</p>
<p><strong>What the documentation led us to believe</strong>: This would &quot;just work.&quot; The docs show examples, explain the syntax, and give the impression that 200 rewrites are fully supported.</p>
<p><strong>What actually happened</strong>: Wrangler immediately complained about &quot;infinite loop detected&quot; for most rules and ignored them. The rules that did parse still didn&#39;t work—we got 307 Temporary Redirects instead of 200 rewrites.</p>
<h3>The Infinite Loop Warning</h3>
<p>Wrangler produced warnings like:</p>
<pre><code class="hljs"><span class="hljs-title class_">Infinite</span> loop detected <span class="hljs-keyword">in</span> <span class="hljs-variable language_">this</span> rule and has been ignored. <span class="hljs-title class_">This</span> will cause
a redirect to strip <span class="hljs-string">\`.html\`</span> or <span class="hljs-string">\`/index\`</span> and end up triggering <span class="hljs-variable language_">this</span> rule again.
</code></pre><p>This warning is cryptic. What does &quot;strip <code>.html</code> or <code>/index</code>&quot; mean? Why would rewriting to <code>index.html</code> cause a loop? The documentation doesn&#39;t explain this behavior, leaving developers to guess at what&#39;s happening internally.</p>
<h2>Searching for Answers</h2>
<p>At this point, we turned to web searches and community forums. What we found was disheartening:</p>
<ol>
<li><strong>Multiple community posts</strong> describing the exact same 307/308 redirect issues</li>
<li><strong>A GitHub issue</strong> on the React Router repository specifically about CloudFlare Pages and <code>_redirects</code></li>
<li><strong>Conflicting information</strong> about whether 200 rewrites are actually supported</li>
</ol>
<p>One particularly revealing find was a community post stating that the documentation listed &quot;Rewrites&quot; as &quot;No&quot; (not supported), despite examples in the official docs suggesting otherwise. This contradiction is maddening for developers trying to implement a standard SPA pattern.</p>
<h3>The &quot;Just Remove 404.html&quot; Advice</h3>
<p>Several sources suggested that if you don&#39;t have a <code>404.html</code> file at the root, CloudFlare Pages automatically treats your site as an SPA and serves <code>index.html</code> for missing routes.</p>
<p><strong>The assumption</strong>: This would solve our problem elegantly.</p>
<p><strong>The reality</strong>: This only works for SPAs at the root level. Our SPA lived in a subdirectory (<code>/svg-path-extended/</code>), so this automatic behavior didn&#39;t apply. The documentation doesn&#39;t clarify this limitation.</p>
<h2>The <code>wrangler.toml</code> Detour</h2>
<p>We discovered that CloudFlare Workers (not Pages) has a clean solution for SPAs:</p>
<pre><code class="hljs language-toml">[assets]
directory = <span class="hljs-string">&quot;./public&quot;</span>
not_found_handling = <span class="hljs-string">&quot;single-page-application&quot;</span>
</code></pre><p>This configuration tells the Worker runtime to serve <code>/index.html</code> for navigation requests that don&#39;t match static assets. It&#39;s exactly what we needed.</p>
<p><strong>The assumption</strong>: This would work with <code>wrangler pages dev</code> since Pages and Workers share underlying infrastructure.</p>
<p><strong>The reality</strong>: The <code>not_found_handling</code> setting serves the <em>root</em> <code>index.html</code>, not the one in our subdirectory. Since our site has a landing page at <code>/</code> and the SPA at <code>/svg-path-extended/</code>, this approach couldn&#39;t work without restructuring the entire site.</p>
<h2>The Functions Approach</h2>
<p>CloudFlare Pages supports Functions—serverless functions that can intercept requests. We created a catch-all function at <code>functions/svg-path-extended/[[path]].js</code>:</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">onRequest</span>(<span class="hljs-params">context</span>) {
  <span class="hljs-keyword">const</span> { request, env } = context;
  <span class="hljs-keyword">const</span> url = <span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(request.<span class="hljs-property">url</span>);
  <span class="hljs-keyword">const</span> path = url.<span class="hljs-property">pathname</span>;

  <span class="hljs-keyword">if</span> (!<span class="hljs-regexp">/\\.[a-zA-Z0-9]+$/</span>.<span class="hljs-title function_">test</span>(path)) {
    <span class="hljs-keyword">const</span> indexUrl = <span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(<span class="hljs-string">&#x27;/svg-path-extended/index.html&#x27;</span>, url.<span class="hljs-property">origin</span>);
    <span class="hljs-keyword">return</span> env.<span class="hljs-property">ASSETS</span>.<span class="hljs-title function_">fetch</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Request</span>(indexUrl, request));
  }

  <span class="hljs-keyword">return</span> env.<span class="hljs-property">ASSETS</span>.<span class="hljs-title function_">fetch</span>(request);
}
</code></pre><p><strong>The assumption</strong>: Functions would intercept requests before CloudFlare&#39;s default routing behavior.</p>
<p><strong>The reality</strong>: The 307 redirects were happening <em>before</em> our function even ran. Something in the Pages infrastructure was redirecting requests before they reached our code.</p>
<h2>The <code>_worker.js</code> Solution</h2>
<p>After hours of failed attempts, we finally found a working solution: the <code>_worker.js</code> file. This is an advanced Pages feature that lets you define a Worker that handles all requests to your site.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-keyword">async</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-params">request, env</span>) {
    <span class="hljs-keyword">const</span> url = <span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(request.<span class="hljs-property">url</span>);
    <span class="hljs-keyword">const</span> path = url.<span class="hljs-property">pathname</span>;

    <span class="hljs-comment">// SPA routes under /svg-path-extended/ that don&#x27;t have file extensions</span>
    <span class="hljs-keyword">if</span> (
      path.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">&#x27;/svg-path-extended/&#x27;</span>) &amp;&amp;
      path !== <span class="hljs-string">&#x27;/svg-path-extended/&#x27;</span> &amp;&amp;
      !<span class="hljs-regexp">/\\.\\w+$/</span>.<span class="hljs-title function_">test</span>(path)
    ) {
      url.<span class="hljs-property">pathname</span> = <span class="hljs-string">&#x27;/svg-path-extended/index.html&#x27;</span>;
      <span class="hljs-keyword">return</span> env.<span class="hljs-property">ASSETS</span>.<span class="hljs-title function_">fetch</span>(url.<span class="hljs-title function_">toString</span>());
    }

    <span class="hljs-keyword">return</span> env.<span class="hljs-property">ASSETS</span>.<span class="hljs-title function_">fetch</span>(request);
  }
};
</code></pre><p>This finally worked. But not without additional pain.</p>
<h3>The Stale Process Problem</h3>
<p>During testing, we encountered persistent 500 Internal Server Errors. The Worker code looked correct, but every request failed. After significant debugging, we discovered that <code>wrangler pages dev</code> leaves behind orphaned <code>workerd</code> processes that continue serving stale code. Killing the wrangler process wasn&#39;t enough—we had to hunt down and kill the <code>workerd</code> processes separately.</p>
<p>This is a significant developer experience issue. When your code changes don&#39;t take effect because of zombie processes, you waste time debugging code that isn&#39;t even running.</p>
<h3>The Base URL Solution</h3>
<p>When loading the SPA from nested routes like <code>/svg-path-extended/workspace/new</code>, relative asset paths in the HTML (like <code>styles/theme.css</code>) would resolve incorrectly—the browser would request <code>/svg-path-extended/workspace/styles/theme.css</code> instead of <code>/svg-path-extended/styles/theme.css</code>.</p>
<p>The elegant solution was the HTML <code>&lt;base&gt;</code> tag:</p>
<pre><code class="hljs language-html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">base</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/svg-path-extended/&quot;</span>&gt;</span>
  <span class="hljs-comment">&lt;!-- All relative URLs now resolve from /svg-path-extended/ --&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
</code></pre><p>This single line ensures all relative URLs in the document—including those in Shadow DOM components—resolve correctly regardless of the current browser URL.</p>
<h2>What CloudFlare Could Do Better</h2>
<h3>1. Be Explicit About <code>_redirects</code> Limitations</h3>
<p>The documentation should clearly state:</p>
<ul>
<li>Whether 200 rewrites actually work in production (not just examples that imply they do)</li>
<li>What causes the &quot;infinite loop&quot; warnings and how to avoid them</li>
<li>That <code>_redirects</code> behavior differs between <code>wrangler pages dev</code> and production</li>
</ul>
<h3>2. Document the Subdirectory SPA Pattern</h3>
<p>Many real-world sites have SPAs in subdirectories. The docs should include:</p>
<ul>
<li>A complete working example of this pattern</li>
<li>Explanation of why the &quot;remove 404.html&quot; trick doesn&#39;t work for subdirectories</li>
<li>The recommended solution (whether that&#39;s <code>_worker.js</code> or something else)</li>
</ul>
<h3>3. Document <code>_worker.js</code> More Prominently</h3>
<p>This feature is buried in advanced documentation. Given that it&#39;s often the only reliable solution for complex routing, it deserves more visibility and complete examples.</p>
<h3>4. Fix the <code>workerd</code> Zombie Process Issue</h3>
<p>Developers shouldn&#39;t have to manually hunt down orphaned processes. <code>wrangler pages dev</code> should clean up after itself, or at least warn when stale processes are detected.</p>
<h3>5. Align Local and Production Behavior</h3>
<p>The 307/308 redirects we saw locally should match production behavior. Developers shouldn&#39;t have to deploy to production to test whether their routing works.</p>
<h2>Conclusion</h2>
<p>What should have been a 10-minute configuration task became a hours-long debugging session. The core issue isn&#39;t that CloudFlare Pages can&#39;t handle SPA routing—it clearly can, with <code>_worker.js</code>. The issue is that the documentation guides developers toward solutions that don&#39;t work (<code>_redirects</code> with 200 rewrites), while the solution that does work (<code>_worker.js</code>) is poorly documented and not presented as the primary approach.</p>
<p>For developers facing similar struggles: skip the <code>_redirects</code> file for complex SPA routing. Go directly to <code>_worker.js</code>. It gives you full control, works reliably, and once you understand the pattern, it&#39;s actually simpler than trying to make <code>_redirects</code> rules work.</p>
<p>The CloudFlare Pages platform is powerful, but its documentation needs significant improvement to match that power. Until then, blog posts like this one—born from developer frustration—will have to fill the gaps.</p>
`,
  'seo-pages-cloudflare-workers-routing': `<h1>Adding SEO Pages to a CloudFlare Pages SPA: The Routing Sequel</h1>
<h2>The Goal</h2>
<p>After getting our SPA working on CloudFlare Pages (a saga documented in <a href="/pathogen/blog/cloudflare-pages-spa-routing-struggle">the first post</a>), we had a new problem: search engines couldn&#39;t see any of our content. The SPA renders everything client-side with Web Components and Shadow DOM. Googlebot sees an empty shell. Docs, workspace galleries, curated showcases — all invisible to crawlers.</p>
<p>The plan was straightforward: add three SEO-friendly pages that render real HTML.</p>
<ol>
<li><strong>Docs</strong> — static HTML generated at build time, served from the filesystem</li>
<li><strong>Explore</strong> — a paginated grid of public workspaces, rendered by the worker at request time</li>
<li><strong>Featured</strong> — an admin-curated showcase, also worker-rendered</li>
</ol>
<p>All three would share navigation look-and-feel with the SPA. Users clicking between them and the SPA should feel like they&#39;re on one coherent site.</p>
<p>We already had <code>_worker.js</code> handling SPA routing. Extending it to serve SEO pages seemed like it would be the easy part. It was not.</p>
<h2>The Architecture</h2>
<p>The routing hierarchy we needed was simple:</p>
<pre><code class="hljs">/pathogen/api/*         → API handlers (existing)
/pathogen/docs          → static HTML file
/pathogen/explore       → worker-rendered HTML
/pathogen/featured      → worker-rendered HTML
/pathogen/* (no ext)    → SPA index.html (existing)
everything <span class="hljs-keyword">else</span>         → static assets (existing)
</code></pre><p>Worker-rendered pages were easy — the worker already intercepts all requests, so adding <code>renderExplorePage()</code> and <code>renderFeaturedPage()</code> functions was just a matter of checking the path and returning a <code>new Response()</code> with HTML content. No platform surprises there.</p>
<p>The static docs page, however, introduced a cascade of platform behaviors we didn&#39;t expect.</p>
<h2>Surprise 1: The 308 Redirect Phantom</h2>
<p>We generated a complete HTML page at <code>public/pathogen/docs/index.html</code> during the build. The plan was simple: when the worker sees <code>/pathogen/docs</code>, use <code>env.ASSETS.fetch()</code> to serve the static file.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">if</span> (path === <span class="hljs-string">&#x27;/pathogen/docs&#x27;</span> || path === <span class="hljs-string">&#x27;/pathogen/docs/&#x27;</span>) {
  url.<span class="hljs-property">pathname</span> = <span class="hljs-string">&#x27;/pathogen/docs/index.html&#x27;</span>;
  <span class="hljs-keyword">return</span> env.<span class="hljs-property">ASSETS</span>.<span class="hljs-title function_">fetch</span>(url.<span class="hljs-title function_">toString</span>());
}
</code></pre><p>Testing locally with <code>curl</code>, we got back 1,234 bytes — far too small for our 160KB docs page. That&#39;s the SPA&#39;s <code>index.html</code>. Our route wasn&#39;t matching.</p>
<p>More investigation revealed something unexpected: requesting <code>/pathogen/docs/index.html</code> directly returned a <strong>308 Permanent Redirect</strong> to <code>/pathogen/docs/</code>. CloudFlare Pages automatically strips <code>.html</code> extensions and trailing <code>/index</code> from URLs, issuing 308 redirects. This is the platform&#39;s &quot;pretty URLs&quot; feature, and it runs at the static asset layer — potentially before or alongside the worker.</p>
<p>Here&#39;s what&#39;s confusing: this behavior doesn&#39;t affect our worker route. The worker intercepts <code>/pathogen/docs</code> before the static asset layer gets involved. The 308 exists if someone visits <code>/pathogen/docs/index.html</code> directly, but our worker code never does — it catches the clean URL first. So the 308 was a red herring. But we spent considerable time investigating it because it seemed like it could explain why the wrong content was being served.</p>
<p>The actual problem was something else entirely.</p>
<h2>Surprise 2: The Zombie Worker Strikes Again</h2>
<p>After adding the SEO routes, rebuilding the site, and restarting the dev server, our new routes still returned the SPA. Every request to <code>/pathogen/docs</code> showed &quot;My Workspaces&quot; — the SPA landing page.</p>
<p>If this sounds familiar, it should. We documented the exact same problem in our <a href="/pathogen/blog/cloudflare-pages-spa-routing-struggle">first CloudFlare Pages blog post</a>. The <code>wrangler pages dev</code> command spawns a <code>workerd</code> subprocess that can survive the parent process being killed. When you restart <code>wrangler</code>, it may start a fresh process while the old one keeps running on the same port — or the old one keeps answering requests while the new one fails to bind.</p>
<p>The fix was the same as before: stop the dev server, verify no orphaned <code>workerd</code> processes are running, and restart cleanly. After that, all three SEO routes served the correct content.</p>
<p>This is now a pattern. Every time we make significant changes to <code>_worker.js</code>, we have to be paranoid about stale processes. The platform doesn&#39;t warn you. The old code just keeps running while you stare at your changes wondering why they don&#39;t work.</p>
<h2>Surprise 3: The Build Pipeline Race</h2>
<p>Our build pipeline runs in stages:</p>
<pre><code class="hljs">npm run build           → compile the library
npm run <span class="hljs-attr">build</span>:docs      → generate <span class="hljs-keyword">static</span> docs <span class="hljs-variable constant_">HTML</span>
npm run <span class="hljs-attr">build</span>:blog      → generate blog content <span class="hljs-variable language_">module</span>
tsx build-website.<span class="hljs-property">ts</span>    → assemble everything into public/
</code></pre><p>The docs build generates <code>website/docs-static/index.html</code> — a complete HTML page with sidebar navigation, syntax highlighting, and progressive enhancement scripts. The website build then copies it to <code>public/pathogen/docs/index.html</code>.</p>
<p>But here&#39;s the trap: <code>build-website.ts</code> starts by wiping the entire <code>public/</code> directory. If the docs build wrote directly to <code>public/pathogen/docs/</code>, those files would be deleted moments later when the website build started.</p>
<p>We initially made this mistake. The docs page generated beautifully, the website build completed successfully, but the docs page was gone — replaced by a clean copy of the SPA without the static docs.</p>
<p>The fix was an intermediate output directory. The docs build writes to <code>website/docs-static/</code>, which the website build copies into <code>public/pathogen/docs/</code> after the clean step. Simple, but the kind of issue that&#39;s invisible when each build step works correctly in isolation.</p>
<p>This isn&#39;t a CloudFlare-specific problem, but it&#39;s the kind of subtle ordering bug that emerges when you&#39;re juggling static generation, worker rendering, and SPA routing in a single deployment.</p>
<h2>Surprise 4: Static Assets and Worker Priority</h2>
<p>CloudFlare Pages has an implicit priority order: static assets are served first, and the worker handles everything else. This means if you have a file at <code>public/pathogen/docs/index.html</code>, the platform might serve it before your worker even runs.</p>
<p>In practice, this worked in our favor for the docs page — but it also meant we needed to be deliberate about which routes are handled by the worker versus served as static assets. For <code>/pathogen/docs</code>, the worker explicitly hands off to the static asset layer via <code>env.ASSETS.fetch()</code>. For <code>/pathogen/explore</code> and <code>/pathogen/featured</code>, the worker generates HTML on the fly.</p>
<p>The mental model you need: the worker is a middleware layer, and <code>env.ASSETS.fetch()</code> is how you call &quot;next&quot; to let the static asset layer handle a request. If you don&#39;t call it, the worker is the end of the line.</p>
<p>What the documentation doesn&#39;t make clear is the interaction between the worker, the static asset layer, and the 308 redirect behavior. All three are happening, and understanding which runs when requires experimentation rather than documentation.</p>
<h2>The Navigation Consistency Problem</h2>
<p>With three rendering modes — SPA (client-side), static (build-time), and worker (request-time) — keeping navigation consistent is harder than it sounds.</p>
<p>The SPA uses a <code>&lt;app-header&gt;</code> Web Component with Shadow DOM. The static docs page and worker-rendered pages use plain HTML. They need to look identical: same 56px height, same logo, same nav links, same hover states, same theme toggle.</p>
<p>Our first pass duplicated the nav bar CSS and HTML across all three rendering contexts. This immediately created a problem: the SPA had a theme toggle and Preferences link that the SEO pages didn&#39;t. Clicking from Docs to Workspaces, the nav bar would gain two elements. Clicking back, they&#39;d disappear. The effect was jarring — the navigation felt broken even though every page was technically correct in isolation.</p>
<p>The fix had two parts. First, we extracted the theme toggle into a standalone Web Component (<code>&lt;theme-toggle&gt;</code>) that works in any context — SPA or static HTML. It reads and writes the same <code>localStorage</code> key, dispatches the same events, and needs no framework or imports. Adding it to SEO pages is just a <code>&lt;script type=&quot;module&quot;&gt;</code> tag and a <code>&lt;theme-toggle&gt;</code> element in the header.</p>
<p>Second, we added the Preferences link to every page&#39;s navigation — SEO pages included. Even though Preferences is an SPA route, linking to it from static pages works via a full page load. The important thing is that every nav bar has the same links in the same order.</p>
<h2>Flash of Wrong Theme</h2>
<p>Static HTML pages have a subtlety that SPAs handle automatically: the theme. Our SPA initializes the theme manager before any rendering occurs, so the user never sees a flash of the wrong color scheme. Static pages, however, start rendering immediately — before any JavaScript runs.</p>
<p>If a user has dark mode saved in <code>localStorage</code> but the page&#39;s HTML defaults to light, they&#39;ll see a brief flash of light theme before the JS kicks in and switches to dark. The fix is a tiny inline <code>&lt;script&gt;</code> in the <code>&lt;head&gt;</code> — before the CSS even loads:</p>
<pre><code class="hljs language-javascript">(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>){
  <span class="hljs-keyword">var</span> t = <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&#x27;pathogen-theme&#x27;</span>);
  <span class="hljs-keyword">if</span> (t === <span class="hljs-string">&#x27;light&#x27;</span> || t === <span class="hljs-string">&#x27;dark&#x27;</span>) {
    <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&#x27;data-theme&#x27;</span>, t);
  }
})();
</code></pre><p>This runs synchronously, blocking the parser for microseconds while it sets the theme attribute. By the time the browser processes the <code>&lt;link rel=&quot;stylesheet&quot;&gt;</code> for <code>theme.css</code>, the correct custom properties are already active. No flash.</p>
<h2>The <code>robots.txt</code> and <code>sitemap.xml</code> Dance</h2>
<p>We also needed to tell search engines about the new pages. This meant generating <code>robots.txt</code> (allow these paths, disallow those) and <code>sitemap.xml</code> (here are all the URLs we want indexed).</p>
<p>The sitemap needed to be dynamic — blog posts are added as markdown files, and the build should discover them automatically. We enumerate <code>website/blog/*.md</code>, strip the extension to get slugs, and generate <code>&lt;url&gt;</code> entries for each.</p>
<p>One oversight: we initially forgot to include <code>/pathogen/blog</code> in both <code>robots.txt</code> and <code>sitemap.xml</code>. The blog pages were already crawlable via the SPA&#39;s static rendering, but without being listed in robots.txt and the sitemap, search engines had no way to discover them efficiently. A small thing, but the kind of omission that undermines the entire SEO effort.</p>
<h2>Lessons Learned</h2>
<h3>1. Always restart <code>wrangler</code> cleanly</h3>
<p>Kill orphaned <code>workerd</code> processes. Always. Check <code>ps aux | grep workerd</code> after stopping the dev server. This is the single most time-wasting gotcha in CloudFlare Pages development. Until CloudFlare fixes the process management, treat every restart as potentially stale.</p>
<h3>2. Build pipeline ordering matters</h3>
<p>If one build step cleans an output directory and another writes to it, they need to run in the right order with an intermediate staging area. This is Build Systems 101, but it&#39;s easy to overlook when you&#39;re adding features incrementally and each step works in isolation.</p>
<h3>3. Navigation consistency beats navigation logic</h3>
<p>When you have multiple rendering modes, every page should show the same navigation — same links, same order, same interactive elements. It&#39;s tempting to hide links that &quot;don&#39;t apply&quot; on certain pages. Don&#39;t. Users perceive the nav bar as a constant. When it changes between pages, the site feels broken.</p>
<h3>4. Theme flash prevention needs to be in <code>&lt;head&gt;</code></h3>
<p>Any page that supports user-selected themes needs an inline script in <code>&lt;head&gt;</code> that runs before the stylesheet loads. This is well-known in the SSR world but easy to forget when you&#39;re adding static pages to an existing SPA.</p>
<h3>5. Standalone Web Components bridge the gap</h3>
<p>When you need UI elements that work identically across SPA and static contexts, standalone Web Components — no imports, no framework, self-registering — are the right abstraction. Our <code>&lt;theme-toggle&gt;</code> works everywhere because it depends on nothing except the DOM and <code>localStorage</code>.</p>
<h2>Conclusion</h2>
<p>Adding SEO-friendly pages to a CloudFlare Pages SPA is achievable, but the platform makes you earn it. The documentation doesn&#39;t cover the interaction between workers, static assets, and automatic redirects. The dev server&#39;s process management will waste your time. And the challenge of maintaining visual consistency across rendering modes is a design problem that no platform can solve for you.</p>
<p>The final architecture — static HTML for docs, worker-rendered HTML for dynamic pages, SPA for interactive features, all sharing a common nav bar and theme system — works well. Getting there required more debugging than coding. As with our first CloudFlare Pages adventure, the platform is powerful enough to do everything we need. The documentation just hasn&#39;t caught up with the use cases yet.</p>
`,
  'svg-serialization-trap': `<h1>The SVG Serialization Trap: Why <code>createElementNS</code> Broke Our Thumbnail Pipeline</h1>
<h2>The Setup</h2>
<p>We have a web app where users create SVG artwork through code. Each workspace compiles to an SVG path, rendered live in the browser. Thumbnails are generated client-side: clone the SVG, rasterize it to PNG via <code>Image</code> + <code>createImageBitmap</code>, then upload.</p>
<p>This pipeline worked perfectly for user-initiated thumbnails. But when we built an admin backfill tool to generate thumbnails in bulk for workspaces that didn&#39;t have them yet, every single thumbnail came back blank — just the background color, no path content.</p>
<h2>Three Paths, One Broken</h2>
<p>Our app had three ways to generate a thumbnail, all feeding into the same <code>generateThumbnail</code> function:</p>
<ol>
<li><strong>Auto-save</strong> (user edits, goes idle): clones the live SVG from the preview pane</li>
<li><strong>Manual crop</strong> (user picks a crop region): clones the same live SVG</li>
<li><strong>Admin backfill</strong> (new): compiles the workspace code, builds an SVG programmatically, passes it in</li>
</ol>
<p>Paths 1 and 2 worked. Path 3 produced blank images. The shared rasterization pipeline was identical — so the difference had to be in how the SVG element was created.</p>
<h2>The Working Path</h2>
<p>The live preview SVG is created by the browser&#39;s HTML parser from a template:</p>
<pre><code class="hljs language-html"><span class="hljs-tag">&lt;<span class="hljs-name">svg</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;preview&quot;</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.w3.org/2000/svg&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">rect</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;preview-bg&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;100%&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;100%&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">rect</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">path</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;preview-path&quot;</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">&quot;none&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">path</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span>
</code></pre><p>Attributes are set dynamically via <code>setAttribute()</code>. When it&#39;s time to generate a thumbnail, the code clones this element, adjusts the <code>viewBox</code> for cropping, serializes it, and loads the result as an image:</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> clone = svgElement.<span class="hljs-title function_">cloneNode</span>(<span class="hljs-literal">true</span>);
clone.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&#x27;viewBox&#x27;</span>, <span class="hljs-string">\`<span class="hljs-subst">\${cropX}</span> <span class="hljs-subst">\${cropY}</span> <span class="hljs-subst">\${cropSize}</span> <span class="hljs-subst">\${cropSize}</span>\`</span>);
clone.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&#x27;width&#x27;</span>, <span class="hljs-title class_">String</span>(rasterSize));
clone.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&#x27;height&#x27;</span>, <span class="hljs-title class_">String</span>(rasterSize));

<span class="hljs-keyword">const</span> svgString = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLSerializer</span>().<span class="hljs-title function_">serializeToString</span>(clone);
<span class="hljs-keyword">const</span> blob = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Blob</span>([svgString], { <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;image/svg+xml;charset=utf-8&#x27;</span> });
<span class="hljs-keyword">const</span> url = <span class="hljs-variable constant_">URL</span>.<span class="hljs-title function_">createObjectURL</span>(blob);

<span class="hljs-keyword">const</span> img = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Image</span>();
img.<span class="hljs-property">src</span> = url;
<span class="hljs-comment">// ... wait for load, createImageBitmap, draw to canvas</span>
</code></pre><p>This works every time.</p>
<h2>The Broken Path</h2>
<p>The admin backfill doesn&#39;t have a live preview — it fetches workspace data from an API, compiles the code to get path data, and constructs an SVG element programmatically:</p>
<pre><code class="hljs language-javascript"><span class="hljs-title function_">_createTempSvg</span>(<span class="hljs-params">state</span>) {
  <span class="hljs-keyword">const</span> ns = <span class="hljs-string">&#x27;http://www.w3.org/2000/svg&#x27;</span>;
  <span class="hljs-keyword">const</span> svg = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElementNS</span>(ns, <span class="hljs-string">&#x27;svg&#x27;</span>);
  svg.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&#x27;xmlns&#x27;</span>, ns);
  svg.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&#x27;width&#x27;</span>, state.<span class="hljs-property">width</span>);
  svg.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&#x27;height&#x27;</span>, state.<span class="hljs-property">height</span>);
  svg.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&#x27;viewBox&#x27;</span>, <span class="hljs-string">\`0 0 <span class="hljs-subst">\${state.width}</span> <span class="hljs-subst">\${state.height}</span>\`</span>);

  <span class="hljs-keyword">const</span> bg = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElementNS</span>(ns, <span class="hljs-string">&#x27;rect&#x27;</span>);
  bg.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&#x27;width&#x27;</span>, state.<span class="hljs-property">width</span>);
  bg.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&#x27;height&#x27;</span>, state.<span class="hljs-property">height</span>);
  bg.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&#x27;fill&#x27;</span>, state.<span class="hljs-property">background</span>);
  svg.<span class="hljs-title function_">appendChild</span>(bg);

  <span class="hljs-keyword">const</span> path = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElementNS</span>(ns, <span class="hljs-string">&#x27;path&#x27;</span>);
  path.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&#x27;d&#x27;</span>, state.<span class="hljs-property">pathData</span>);
  path.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&#x27;stroke&#x27;</span>, state.<span class="hljs-property">stroke</span>);
  path.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&#x27;stroke-width&#x27;</span>, state.<span class="hljs-property">strokeWidth</span>);
  path.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&#x27;fill&#x27;</span>, state.<span class="hljs-property">fillEnabled</span> ? state.<span class="hljs-property">fill</span> : <span class="hljs-string">&#x27;none&#x27;</span>);
  svg.<span class="hljs-title function_">appendChild</span>(path);

  <span class="hljs-keyword">return</span> svg;
}
</code></pre><p>This element was then passed through the exact same <code>clone → serialize → Image → bitmap</code> pipeline. Same function, same code path. But the thumbnails were blank.</p>
<h2>What We Saw</h2>
<p>The generated thumbnails weren&#39;t completely empty. The background rectangle rendered correctly — a light gray <code>#f5f5f5</code> fill covering the full viewport. But the <code>&lt;path&gt;</code> element, despite having valid <code>d</code> attribute data (verified via console logging), rendered nothing.</p>
<p>This told us:</p>
<ul>
<li>The SVG loaded successfully as an image (background appeared)</li>
<li>The <code>&lt;path&gt;</code> element was present in the serialized markup</li>
<li>Something about the serialized output was causing the browser&#39;s SVG-as-image renderer to silently ignore the path</li>
</ul>
<h2>The Investigation</h2>
<p>We verified that <code>result.path</code> from the compiler contained valid, non-empty SVG path data. We verified the <code>viewBox</code>, <code>width</code>, and <code>height</code> were set correctly. We checked for namespace issues, tried stripping inline CSS styles from the element, and even added a wait-and-retry mechanism in case of timing conflicts.</p>
<p>None of it helped.</p>
<p>The frustrating part was that both SVGs — the one from the HTML parser and the one from <code>createElementNS</code> — should have been structurally identical after serialization. An SVG is an SVG, right?</p>
<h2>The Root Cause</h2>
<p>When you create SVG elements with <code>document.createElementNS()</code> in an HTML document, you&#39;re creating DOM nodes that live in the SVG namespace but exist within the HTML DOM. When <code>XMLSerializer.serializeToString()</code> serializes these nodes back to XML, it can produce subtly different output than what you&#39;d get from a browser-parsed SVG.</p>
<p>The exact nature of these differences is browser-dependent and poorly documented. They can include redundant namespace declarations on child elements, different attribute ordering, or namespace prefix handling that — while technically valid XML — trips up the browser&#39;s SVG-as-image renderer. The SVG-as-image rendering path (used when loading SVG via <code>new Image()</code>) is more restrictive than the inline SVG rendering path, and it may reject or silently ignore markup that inline rendering handles fine.</p>
<p>The key insight: <strong>the problem wasn&#39;t in the SVG structure, it was in the serialization roundtrip</strong>. The same logical SVG, when created via DOM APIs and serialized, produced different bytes than when created by the HTML parser and serialized — and those different bytes didn&#39;t survive the <code>Image</code> loading step.</p>
<h2>The Fix</h2>
<p>Once we identified that the DOM-to-string roundtrip was the culprit, the fix was almost trivially simple: don&#39;t do the roundtrip. Build the SVG string directly.</p>
<pre><code class="hljs language-javascript"><span class="hljs-title function_">_buildSvgString</span>(<span class="hljs-params">state</span>) {
  <span class="hljs-keyword">const</span> w = state.<span class="hljs-property">width</span>;
  <span class="hljs-keyword">const</span> h = state.<span class="hljs-property">height</span>;
  <span class="hljs-keyword">const</span> cropSize = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(w, h);
  <span class="hljs-keyword">const</span> cropX = (w - cropSize) / <span class="hljs-number">2</span>;
  <span class="hljs-keyword">const</span> cropY = (h - cropSize) / <span class="hljs-number">2</span>;
  <span class="hljs-keyword">const</span> rasterSize = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(<span class="hljs-number">1024</span>, <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">ceil</span>(cropSize), <span class="hljs-number">4096</span>));
  <span class="hljs-keyword">const</span> fill = state.<span class="hljs-property">fillEnabled</span> ? state.<span class="hljs-property">fill</span> : <span class="hljs-string">&#x27;none&#x27;</span>;

  <span class="hljs-comment">// Escape path data for XML attribute context</span>
  <span class="hljs-keyword">const</span> d = (state.<span class="hljs-property">pathData</span> || <span class="hljs-string">&#x27;&#x27;</span>)
    .<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/&amp;/g</span>, <span class="hljs-string">&#x27;&amp;amp;&#x27;</span>)
    .<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/&quot;/g</span>, <span class="hljs-string">&#x27;&amp;quot;&#x27;</span>);

  <span class="hljs-keyword">return</span> <span class="hljs-string">\`&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;<span class="hljs-subst">\${rasterSize}</span>&quot; height=&quot;<span class="hljs-subst">\${rasterSize}</span>&quot; viewBox=&quot;<span class="hljs-subst">\${cropX}</span> <span class="hljs-subst">\${cropY}</span> <span class="hljs-subst">\${cropSize}</span> <span class="hljs-subst">\${cropSize}</span>&quot;&gt;&lt;rect width=&quot;<span class="hljs-subst">\${w}</span>&quot; height=&quot;<span class="hljs-subst">\${h}</span>&quot; fill=&quot;<span class="hljs-subst">\${state.background}</span>&quot;/&gt;&lt;path d=&quot;<span class="hljs-subst">\${d}</span>&quot; stroke=&quot;<span class="hljs-subst">\${state.stroke}</span>&quot; stroke-width=&quot;<span class="hljs-subst">\${state.strokeWidth}</span>&quot; fill=&quot;<span class="hljs-subst">\${fill}</span>&quot;/&gt;&lt;/svg&gt;\`</span>;
}
</code></pre><p>This string is passed directly to <code>generateThumbnail</code> via an options parameter, which skips the clone-and-serialize step entirely when a pre-built string is provided:</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">if</span> (options?.<span class="hljs-property">svgString</span>) {
  svgString = options.<span class="hljs-property">svgString</span>;
} <span class="hljs-keyword">else</span> {
  <span class="hljs-keyword">const</span> clone = <span class="hljs-title function_">cloneSvgWithoutGrid</span>(svgElement);
  <span class="hljs-comment">// ... crop, resize, serialize as before</span>
  svgString = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLSerializer</span>().<span class="hljs-title function_">serializeToString</span>(clone);
}

<span class="hljs-keyword">const</span> blob = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Blob</span>([svgString], { <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;image/svg+xml;charset=utf-8&#x27;</span> });
</code></pre><p>The existing paths (auto-save and manual crop) continue to use the DOM clone pipeline, which works because those SVG elements were created by the HTML parser in the first place. The admin backfill now bypasses the DOM entirely, producing clean SVG markup that the image renderer handles correctly.</p>
<h2>Takeaways</h2>
<p><strong><code>XMLSerializer</code> is not a lossless roundtrip.</strong> Creating SVG elements with <code>createElementNS</code>, setting attributes, then serializing with <code>XMLSerializer</code> does not necessarily produce the same output as writing that SVG as a string. The DOM is an abstraction layer, and serialization can introduce artifacts.</p>
<p><strong>SVG-as-image rendering is stricter than inline SVG.</strong> Browsers apply tighter parsing and security restrictions when loading SVG via <code>&lt;img&gt;</code> or <code>new Image()</code>. Markup that renders perfectly as inline <code>&lt;svg&gt;</code> in your document may silently fail when loaded as an image.</p>
<p><strong>When you control the input, skip the DOM.</strong> If you&#39;re generating SVG from known data (not cloning a live element), build the string directly. It&#39;s simpler, more predictable, and avoids an entire class of serialization edge cases. Template literals make this clean and readable.</p>
<p>The irony is that the &quot;proper&quot; approach — using the DOM API to construct a well-formed SVG element — was the one that broke. Sometimes the simplest tool is the right one.</p>
`,
};
