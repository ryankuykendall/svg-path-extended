// Auto-generated by scripts/build-docs.js
// Do not edit manually - edit the markdown files in /docs/ instead

export const gettingStarted = `<h1>Getting Started</h1>
<p>svg-path-extended is a language that extends SVG path syntax with variables, expressions, control flow, and functions. It compiles to standard SVG path data that works in any browser or graphics application.</p>
<h2>Your First Path</h2>
<p>Try this simple example in the playground:</p>
<pre><code class="hljs"><span class="hljs-comment">// A simple rectangle using variables</span>
<span class="hljs-keyword">let</span> size = <span class="hljs-number">50</span>
<span class="hljs-keyword">let</span> x = <span class="hljs-number">10</span>
<span class="hljs-keyword">let</span> y = <span class="hljs-number">10</span>

M x y
h size
v size
h <span class="hljs-title function_">calc</span>(-size)
Z
</code></pre><p>This creates a rectangle by:</p>
<ol>
<li>Moving to position (10, 10)</li>
<li>Drawing a horizontal line of length 50</li>
<li>Drawing a vertical line of length 50</li>
<li>Drawing a horizontal line back</li>
<li>Closing the path</li>
</ol>
<h2>Why svg-path-extended?</h2>
<p>SVG paths are powerful but writing them by hand is tedious:</p>
<pre><code class="hljs"><span class="hljs-comment">// Standard SVG - repetitive coordinates</span>
M <span class="hljs-number">20</span> <span class="hljs-number">20</span> L <span class="hljs-number">80</span> <span class="hljs-number">20</span> L <span class="hljs-number">80</span> <span class="hljs-number">80</span> L <span class="hljs-number">20</span> <span class="hljs-number">80</span> Z
M <span class="hljs-number">100</span> <span class="hljs-number">20</span> L <span class="hljs-number">160</span> <span class="hljs-number">20</span> L <span class="hljs-number">160</span> <span class="hljs-number">80</span> L <span class="hljs-number">100</span> <span class="hljs-number">80</span> Z
M <span class="hljs-number">180</span> <span class="hljs-number">20</span> L <span class="hljs-number">240</span> <span class="hljs-number">20</span> L <span class="hljs-number">240</span> <span class="hljs-number">80</span> L <span class="hljs-number">180</span> <span class="hljs-number">80</span> Z
</code></pre><p>With svg-path-extended, you can use variables and loops:</p>
<pre><code class="hljs"><span class="hljs-comment">// svg-path-extended - DRY and readable</span>
<span class="hljs-keyword">let</span> size = <span class="hljs-number">60</span>
<span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">0.</span><span class="hljs-number">.3</span>) {
  <span class="hljs-title function_">rect</span>(<span class="hljs-title function_">calc</span>(<span class="hljs-number">20</span> + i * <span class="hljs-number">80</span>), <span class="hljs-number">20</span>, size, size)
}
</code></pre><h2>Key Features</h2>
<h3>Variables</h3>
<p>Store and reuse values:</p>
<pre><code class="hljs"><span class="hljs-keyword">let</span> width = <span class="hljs-number">200</span>
<span class="hljs-keyword">let</span> height = <span class="hljs-number">100</span>
<span class="hljs-keyword">let</span> centerX = <span class="hljs-title function_">calc</span>(width / <span class="hljs-number">2</span>)
</code></pre><h3>Expressions with calc()</h3>
<p>Use math in path commands:</p>
<pre><code class="hljs"><span class="hljs-keyword">let</span> r = <span class="hljs-number">50</span>
M <span class="hljs-title function_">calc</span>(<span class="hljs-number">100</span> - r) <span class="hljs-number">100</span>
L <span class="hljs-title function_">calc</span>(<span class="hljs-number">100</span> + r) <span class="hljs-number">100</span>
</code></pre><h3>Loops</h3>
<p>Repeat patterns easily:</p>
<pre><code class="hljs"><span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">0.</span><span class="hljs-number">.10</span>) {
  <span class="hljs-title function_">circle</span>(<span class="hljs-title function_">calc</span>(<span class="hljs-number">20</span> + i * <span class="hljs-number">30</span>), <span class="hljs-number">100</span>, <span class="hljs-number">10</span>)
}
</code></pre><h3>Functions</h3>
<p>Define reusable shapes:</p>
<pre><code class="hljs">fn <span class="hljs-title function_">square</span>(<span class="hljs-params">x, y, size</span>) {
  <span class="hljs-title function_">rect</span>(x, y, size, size)
}

<span class="hljs-title function_">square</span>(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">50</span>)
<span class="hljs-title function_">square</span>(<span class="hljs-number">70</span>, <span class="hljs-number">10</span>, <span class="hljs-number">50</span>)
</code></pre><h3>Built-in Shapes</h3>
<p>Common shapes are included:</p>
<pre><code class="hljs"><span class="hljs-title function_">circle</span>(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">50</span>)
<span class="hljs-title function_">rect</span>(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">80</span>, <span class="hljs-number">60</span>)
<span class="hljs-title function_">polygon</span>(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">40</span>, <span class="hljs-number">6</span>)  <span class="hljs-comment">// hexagon</span>
<span class="hljs-title function_">star</span>(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">50</span>, <span class="hljs-number">25</span>, <span class="hljs-number">5</span>)
</code></pre><h2>Next Steps</h2>
<ul>
<li><strong>Syntax Reference</strong> - Learn all the language features</li>
<li><strong>Standard Library</strong> - Explore built-in functions</li>
<li><strong>Examples</strong> - See practical patterns and recipes</li>
</ul>
`;

export const syntax = `<h1>Syntax Reference</h1>
<p>svg-path-extended is a superset of SVG path syntax that adds variables, expressions, control flow, and functions.</p>
<h2>Path Commands</h2>
<p>All standard SVG path commands are supported:</p>
<table>
<thead>
<tr>
<th>Command</th>
<th>Name</th>
<th>Parameters</th>
</tr>
</thead>
<tbody><tr>
<td><code>M</code> / <code>m</code></td>
<td>Move to</td>
<td><code>x y</code></td>
</tr>
<tr>
<td><code>L</code> / <code>l</code></td>
<td>Line to</td>
<td><code>x y</code></td>
</tr>
<tr>
<td><code>H</code> / <code>h</code></td>
<td>Horizontal line</td>
<td><code>x</code></td>
</tr>
<tr>
<td><code>V</code> / <code>v</code></td>
<td>Vertical line</td>
<td><code>y</code></td>
</tr>
<tr>
<td><code>C</code> / <code>c</code></td>
<td>Cubic bezier</td>
<td><code>x1 y1 x2 y2 x y</code></td>
</tr>
<tr>
<td><code>S</code> / <code>s</code></td>
<td>Smooth cubic</td>
<td><code>x2 y2 x y</code></td>
</tr>
<tr>
<td><code>Q</code> / <code>q</code></td>
<td>Quadratic bezier</td>
<td><code>x1 y1 x y</code></td>
</tr>
<tr>
<td><code>T</code> / <code>t</code></td>
<td>Smooth quadratic</td>
<td><code>x y</code></td>
</tr>
<tr>
<td><code>A</code> / <code>a</code></td>
<td>Arc</td>
<td><code>rx ry rotation large-arc sweep x y</code></td>
</tr>
<tr>
<td><code>Z</code> / <code>z</code></td>
<td>Close path</td>
<td>(none)</td>
</tr>
</tbody></table>
<p>Uppercase commands use absolute coordinates; lowercase use relative coordinates.</p>
<pre><code class="hljs">M <span class="hljs-number">0</span> <span class="hljs-number">0</span> L <span class="hljs-number">100</span> <span class="hljs-number">100</span> Z
</code></pre><h2>Variables</h2>
<p>Declare variables with <code>let</code>:</p>
<pre><code class="hljs"><span class="hljs-keyword">let</span> width = <span class="hljs-number">200</span>;
<span class="hljs-keyword">let</span> height = <span class="hljs-number">100</span>;
<span class="hljs-keyword">let</span> centerX = <span class="hljs-number">100</span>;
</code></pre><p>Use variables directly in path commands:</p>
<pre><code class="hljs"><span class="hljs-keyword">let</span> x = <span class="hljs-number">50</span>;
<span class="hljs-keyword">let</span> y = <span class="hljs-number">75</span>;
M x y L <span class="hljs-number">100</span> <span class="hljs-number">100</span>
</code></pre><p><strong>Note</strong>: Single letters that are path commands (M, L, C, etc.) cannot be used as variable names.</p>
<h2>Strings and Template Literals</h2>
<p>String values use double quotes:</p>
<pre><code class="hljs"><span class="hljs-keyword">let</span> name = <span class="hljs-string">&quot;World&quot;</span>;
</code></pre><p>Template literals use backticks with <code>\${expression}</code> interpolation:</p>
<pre><code class="hljs"><span class="hljs-keyword">let</span> greeting = <span class="hljs-string">\`Hello <span class="hljs-subst">\${name}</span>!\`</span>;          <span class="hljs-comment">// &quot;Hello World!&quot;</span>
<span class="hljs-keyword">let</span> msg = <span class="hljs-string">\`Score: <span class="hljs-subst">\${<span class="hljs-number">2</span> + <span class="hljs-number">3</span>}</span>\`</span>;             <span class="hljs-comment">// &quot;Score: 5&quot;</span>
<span class="hljs-keyword">let</span> pos = <span class="hljs-string">\`(<span class="hljs-subst">\${ctx.position.x}</span>, <span class="hljs-subst">\${ctx.position.y}</span>)\`</span>;
</code></pre><p>Template literals are the sole string construction mechanism — the <code>+</code> operator stays strictly numeric. String equality works with <code>==</code> and <code>!=</code>:</p>
<pre><code class="hljs"><span class="hljs-keyword">let</span> mode = <span class="hljs-string">&quot;dark&quot;</span>;
<span class="hljs-keyword">if</span> (mode == <span class="hljs-string">&quot;dark&quot;</span>) { <span class="hljs-comment">/* ... */</span> }
<span class="hljs-keyword">if</span> (mode != <span class="hljs-string">&quot;light&quot;</span>) { <span class="hljs-comment">/* ... */</span> }
</code></pre><h2>Expressions with calc()</h2>
<p>For mathematical expressions, wrap them in <code>calc()</code>:</p>
<pre><code class="hljs"><span class="hljs-keyword">let</span> r = <span class="hljs-number">50</span>;
M <span class="hljs-title function_">calc</span>(<span class="hljs-number">100</span> - r) <span class="hljs-number">100</span>
L <span class="hljs-title function_">calc</span>(<span class="hljs-number">100</span> + r) <span class="hljs-number">100</span>
</code></pre><h3>Supported Operators</h3>
<table>
<thead>
<tr>
<th>Operator</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>+</code></td>
<td>Addition</td>
</tr>
<tr>
<td><code>-</code></td>
<td>Subtraction</td>
</tr>
<tr>
<td><code>*</code></td>
<td>Multiplication</td>
</tr>
<tr>
<td><code>/</code></td>
<td>Division</td>
</tr>
<tr>
<td><code>%</code></td>
<td>Modulo</td>
</tr>
<tr>
<td><code>&lt;</code></td>
<td>Less than</td>
</tr>
<tr>
<td><code>&gt;</code></td>
<td>Greater than</td>
</tr>
<tr>
<td><code>&lt;=</code></td>
<td>Less than or equal</td>
</tr>
<tr>
<td><code>&gt;=</code></td>
<td>Greater than or equal</td>
</tr>
<tr>
<td><code>==</code></td>
<td>Equal</td>
</tr>
<tr>
<td><code>!=</code></td>
<td>Not equal</td>
</tr>
<tr>
<td><code>&amp;&amp;</code></td>
<td>Logical AND</td>
</tr>
<tr>
<td><code>||</code></td>
<td>Logical OR</td>
</tr>
<tr>
<td><code>!</code></td>
<td>Logical NOT (unary)</td>
</tr>
<tr>
<td><code>-</code></td>
<td>Negation (unary)</td>
</tr>
<tr>
<td><code>&lt;&lt;</code></td>
<td>Style block merge</td>
</tr>
</tbody></table>
<p>Operator precedence follows standard mathematical conventions.</p>
<h2>Style Blocks</h2>
<p>Style blocks are CSS-like key-value maps wrapped in <code>\${ }</code>. They&#39;re used for layer styles but are also first-class values — you can store them in variables, merge them, and read their properties.</p>
<h3>Literals</h3>
<pre><code class="hljs"><span class="hljs-keyword">let</span> styles = \${
  <span class="hljs-attr">stroke</span>: #cc0000;
  stroke-<span class="hljs-attr">width</span>: <span class="hljs-number">3</span>;
  <span class="hljs-attr">fill</span>: none;
};
</code></pre><p>Each property is a <code>name: value;</code> declaration. Values are try-evaluated as expressions — if the value parses as a valid expression (like a variable reference or <code>calc()</code>), its result is used. Otherwise the raw string is kept (e.g., <code>rgb(...)</code>, <code>#hex</code>).</p>
<h3>Merge (<code>&lt;&lt;</code>)</h3>
<p>The <code>&lt;&lt;</code> operator combines two style blocks. The right side overrides the left:</p>
<pre><code class="hljs"><span class="hljs-keyword">let</span> base = \${ <span class="hljs-attr">stroke</span>: red; stroke-<span class="hljs-attr">width</span>: <span class="hljs-number">2</span>; };
<span class="hljs-keyword">let</span> merged = base &lt;&lt; \${ stroke-<span class="hljs-attr">width</span>: <span class="hljs-number">4</span>; <span class="hljs-attr">fill</span>: blue; };
<span class="hljs-comment">// Result: stroke: red, stroke-width: 4, fill: blue</span>
</code></pre><p>Multiple merges can be chained: <code>a &lt;&lt; b &lt;&lt; c</code>.</p>
<h3>Property Access</h3>
<p>Use dot notation with camelCase names to read kebab-case properties:</p>
<pre><code class="hljs"><span class="hljs-keyword">let</span> s = \${ stroke-<span class="hljs-attr">width</span>: <span class="hljs-number">4</span>; };
<span class="hljs-keyword">let</span> sw = s.<span class="hljs-property">strokeWidth</span>;  <span class="hljs-comment">// &quot;4&quot; (reads &#x27;stroke-width&#x27;)</span>
</code></pre><p>Property values are always strings.</p>
<h3>Usage in Layers</h3>
<p>Style blocks are used in layer definitions and can be passed as per-element styles on <code>text()</code> and <code>tspan()</code>. See <a href="layers.md">Layers</a> for full details.</p>
<h2>Null</h2>
<p>The <code>null</code> literal represents the absence of a value. It is returned by <code>pop()</code> and <code>shift()</code> on empty arrays, and can be used in variable assignments and conditionals.</p>
<pre><code class="hljs"><span class="hljs-keyword">let</span> x = <span class="hljs-literal">null</span>;
</code></pre><h3>Truthiness</h3>
<p><code>null</code> is falsy in conditionals:</p>
<pre><code class="hljs"><span class="hljs-keyword">let</span> x = <span class="hljs-literal">null</span>;
<span class="hljs-keyword">if</span> (x) {
  <span class="hljs-comment">// not reached</span>
} <span class="hljs-keyword">else</span> {
  M <span class="hljs-number">0</span> <span class="hljs-number">0</span>  <span class="hljs-comment">// this branch runs</span>
}
</code></pre><h3>Equality</h3>
<p><code>null</code> is only equal to itself:</p>
<pre><code class="hljs"><span class="hljs-keyword">if</span> (x == <span class="hljs-literal">null</span>) { <span class="hljs-comment">/* x is null */</span> }
<span class="hljs-keyword">if</span> (x != <span class="hljs-literal">null</span>) { <span class="hljs-comment">/* x has a value */</span> }
</code></pre><p><code>null == 0</code> evaluates to <code>0</code> (false) — null is distinct from zero.</p>
<h3>Error Behavior</h3>
<p>Using <code>null</code> in arithmetic or as a path argument throws a descriptive error:</p>
<pre><code class="hljs"><span class="hljs-keyword">let</span> x = <span class="hljs-literal">null</span>;
<span class="hljs-keyword">let</span> y = x + <span class="hljs-number">1</span>;     <span class="hljs-comment">// Error: Cannot use null in arithmetic expression</span>
M x <span class="hljs-number">0</span>               <span class="hljs-comment">// Error: Cannot use null as a path argument</span>
</code></pre><h2>Arrays</h2>
<p>Arrays hold ordered collections of values. Elements can be numbers, strings, style blocks, other arrays, or <code>null</code>.</p>
<h3>Literals</h3>
<pre><code class="hljs"><span class="hljs-keyword">let</span> empty = [];
<span class="hljs-keyword">let</span> nums = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
<span class="hljs-keyword">let</span> mixed = [<span class="hljs-number">10</span>, <span class="hljs-string">&quot;hello&quot;</span>, [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>]];
</code></pre><h3>Index Access</h3>
<p>Access elements by zero-based index using <code>[expr]</code>:</p>
<pre><code class="hljs"><span class="hljs-keyword">let</span> list = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>];
<span class="hljs-keyword">let</span> first = list[<span class="hljs-number">0</span>];         <span class="hljs-comment">// 10</span>
<span class="hljs-keyword">let</span> second = list[<span class="hljs-number">1</span>];        <span class="hljs-comment">// 20</span>
M list[<span class="hljs-number">0</span>] list[<span class="hljs-number">1</span>]            <span class="hljs-comment">// M 10 20</span>
</code></pre><p>Out-of-bounds access throws an error.</p>
<h3><code>.length</code></h3>
<p>Returns the number of elements:</p>
<pre><code class="hljs"><span class="hljs-keyword">let</span> list = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
<span class="hljs-title function_">log</span>(list.<span class="hljs-property">length</span>);  <span class="hljs-comment">// 3</span>
</code></pre><h3><code>.empty()</code></h3>
<p>Returns <code>1</code> (truthy) if the array has no elements, <code>0</code> (falsy) otherwise:</p>
<pre><code class="hljs"><span class="hljs-keyword">let</span> list = [];
<span class="hljs-keyword">if</span> (list.<span class="hljs-title function_">empty</span>()) {
  <span class="hljs-comment">// list is empty</span>
}
</code></pre><h3>Methods</h3>
<h4><code>.push(value)</code></h4>
<p>Appends a value to the end. Returns the new length.</p>
<pre><code class="hljs"><span class="hljs-keyword">let</span> list = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>];
<span class="hljs-keyword">let</span> len = list.<span class="hljs-title function_">push</span>(<span class="hljs-number">3</span>);  <span class="hljs-comment">// list is now [1, 2, 3], len is 3</span>
</code></pre><h4><code>.pop()</code></h4>
<p>Removes and returns the last element. Returns <code>null</code> if the array is empty.</p>
<pre><code class="hljs"><span class="hljs-keyword">let</span> list = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
<span class="hljs-keyword">let</span> last = list.<span class="hljs-title function_">pop</span>();   <span class="hljs-comment">// last is 3, list is now [1, 2]</span>
<span class="hljs-keyword">let</span> empty = [];
<span class="hljs-keyword">let</span> x = empty.<span class="hljs-title function_">pop</span>();     <span class="hljs-comment">// x is null</span>
</code></pre><h4><code>.unshift(value)</code></h4>
<p>Prepends a value to the start. Returns the new length.</p>
<pre><code class="hljs"><span class="hljs-keyword">let</span> list = [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
list.<span class="hljs-title function_">unshift</span>(<span class="hljs-number">1</span>);  <span class="hljs-comment">// list is now [1, 2, 3]</span>
</code></pre><h4><code>.shift()</code></h4>
<p>Removes and returns the first element. Returns <code>null</code> if the array is empty.</p>
<pre><code class="hljs"><span class="hljs-keyword">let</span> list = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
<span class="hljs-keyword">let</span> first = list.<span class="hljs-title function_">shift</span>();  <span class="hljs-comment">// first is 1, list is now [2, 3]</span>
</code></pre><h3>Reference Semantics</h3>
<p>Arrays are passed by reference. Mutations through one binding are visible through all others:</p>
<pre><code class="hljs"><span class="hljs-keyword">let</span> a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
<span class="hljs-keyword">let</span> b = a;
b.<span class="hljs-title function_">push</span>(<span class="hljs-number">4</span>);
<span class="hljs-title function_">log</span>(a.<span class="hljs-property">length</span>);  <span class="hljs-comment">// 4 — same underlying array</span>
</code></pre><h3>For-Each Iteration</h3>
<p>Iterate over array elements with <code>for (item in list)</code>:</p>
<pre><code class="hljs"><span class="hljs-keyword">let</span> points = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>];
<span class="hljs-keyword">for</span> (p <span class="hljs-keyword">in</span> points) {
  M p <span class="hljs-number">0</span>
}
<span class="hljs-comment">// Produces: M 10 0 M 20 0 M 30 0</span>
</code></pre><p>Destructure to get both item and index with <code>for ([item, index] in list)</code>:</p>
<pre><code class="hljs"><span class="hljs-keyword">let</span> sizes = [<span class="hljs-number">5</span>, <span class="hljs-number">10</span>, <span class="hljs-number">15</span>];
<span class="hljs-keyword">for</span> ([size, i] <span class="hljs-keyword">in</span> sizes) {
  <span class="hljs-title function_">circle</span>(<span class="hljs-title function_">calc</span>(i * <span class="hljs-number">40</span> + <span class="hljs-number">20</span>), <span class="hljs-number">50</span>, size)
}
</code></pre><p>Iterating over an empty array produces no output.</p>
<h2>Angle Units</h2>
<p>Numbers can have angle unit suffixes for convenience:</p>
<table>
<thead>
<tr>
<th>Suffix</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>45deg</code></td>
<td>Degrees (converted to radians internally)</td>
</tr>
<tr>
<td><code>1.5rad</code></td>
<td>Radians (no conversion)</td>
</tr>
<tr>
<td><code>0.25pi</code></td>
<td>Multiplied by π (i.e. <code>0.25 * π</code>)</td>
</tr>
</tbody></table>
<pre><code class="hljs"><span class="hljs-keyword">let</span> angle = 90deg;
M <span class="hljs-title function_">sin</span>(45deg) <span class="hljs-title function_">cos</span>(45deg)

<span class="hljs-comment">// Equivalent to:</span>
<span class="hljs-keyword">let</span> angle = <span class="hljs-title function_">rad</span>(<span class="hljs-number">90</span>);
M <span class="hljs-title function_">sin</span>(<span class="hljs-title function_">rad</span>(<span class="hljs-number">45</span>)) <span class="hljs-title function_">cos</span>(<span class="hljs-title function_">rad</span>(<span class="hljs-number">45</span>))
</code></pre><p>The <code>pi</code> suffix multiplies the number by π. This is especially convenient for polar coordinates and angles expressed as fractions of π:</p>
<pre><code class="hljs"><span class="hljs-keyword">let</span> quarter = <span class="hljs-number">0.</span>25pi;   <span class="hljs-comment">// π/4</span>
<span class="hljs-keyword">let</span> half = <span class="hljs-number">0.</span>5pi;       <span class="hljs-comment">// π/2</span>
<span class="hljs-keyword">let</span> full = 2pi;          <span class="hljs-comment">// 2π</span>
M <span class="hljs-title function_">sin</span>(<span class="hljs-number">0.</span>25pi) <span class="hljs-title function_">cos</span>(<span class="hljs-number">0.</span>25pi)
</code></pre><p>The <code>pi</code> suffix participates in angle unit mismatch checking: <code>calc(0.25pi + 5)</code> throws an error, while <code>calc(90deg + 0.5pi)</code> is allowed (both have angle units).</p>
<p><strong>Note</strong>: The <code>pi</code> suffix only works on numeric literals. For expressions or variables, use <code>mpi(x)</code> (see <a href="stdlib.md">Standard Library</a>).</p>
<h2>For Loops</h2>
<p>Repeat path commands with <code>for</code>:</p>
<pre><code class="hljs"><span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">0.</span><span class="hljs-number">.10</span>) {
  L <span class="hljs-title function_">calc</span>(i * <span class="hljs-number">20</span>) <span class="hljs-title function_">calc</span>(i * <span class="hljs-number">10</span>)
}
</code></pre><p>The range <code>0..10</code> includes both endpoints (0 through 10, giving 11 iterations).</p>
<h3>Descending Ranges</h3>
<p>Ranges automatically count down when start &gt; end:</p>
<pre><code class="hljs"><span class="hljs-comment">// Countdown from 5 to 1</span>
<span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">5.</span><span class="hljs-number">.1</span>) {
  M <span class="hljs-title function_">calc</span>(i * <span class="hljs-number">20</span>) <span class="hljs-number">0</span>
}
<span class="hljs-comment">// Produces: M 100 0 M 80 0 M 60 0 M 40 0 M 20 0</span>
</code></pre><h3>Nested Loops</h3>
<pre><code class="hljs"><span class="hljs-keyword">for</span> (row <span class="hljs-keyword">in</span> <span class="hljs-number">0.</span><span class="hljs-number">.2</span>) {
  <span class="hljs-keyword">for</span> (col <span class="hljs-keyword">in</span> <span class="hljs-number">0.</span><span class="hljs-number">.2</span>) {
    <span class="hljs-title function_">circle</span>(<span class="hljs-title function_">calc</span>(col * <span class="hljs-number">50</span> + <span class="hljs-number">25</span>), <span class="hljs-title function_">calc</span>(row * <span class="hljs-number">50</span> + <span class="hljs-number">25</span>), <span class="hljs-number">10</span>)
  }
}
</code></pre><p>This creates a 3x3 grid (rows 0, 1, 2 and cols 0, 1, 2).</p>
<h2>Conditionals</h2>
<p>Use <code>if</code>, <code>else if</code>, and <code>else</code> for conditional path generation:</p>
<pre><code class="hljs"><span class="hljs-keyword">let</span> size = <span class="hljs-number">100</span>;

<span class="hljs-keyword">if</span> (size &gt; <span class="hljs-number">75</span>) {
  M <span class="hljs-number">0</span> <span class="hljs-number">0</span> L <span class="hljs-number">100</span> <span class="hljs-number">100</span>
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (size &gt; <span class="hljs-number">50</span>) {
  M <span class="hljs-number">0</span> <span class="hljs-number">0</span> L <span class="hljs-number">75</span> <span class="hljs-number">75</span>
} <span class="hljs-keyword">else</span> {
  M <span class="hljs-number">0</span> <span class="hljs-number">0</span> L <span class="hljs-number">50</span> <span class="hljs-number">50</span>
}
</code></pre><p>You can chain as many <code>else if</code> blocks as needed. Comparison results are numeric: <code>1</code> for true, <code>0</code> for false.</p>
<h2>Functions</h2>
<h3>Defining Functions</h3>
<p>Create reusable path generators with <code>fn</code>:</p>
<pre><code class="hljs">fn <span class="hljs-title function_">square</span>(<span class="hljs-params">x, y, size</span>) {
  <span class="hljs-title function_">rect</span>(x, y, size, size)
}
</code></pre><h3>Calling Functions</h3>
<pre><code class="hljs">square(10, 10, 50)
square(70, 10, 50)
</code></pre><p>Functions can call other functions and use all language features.</p>
<h2>Comments</h2>
<p>Line comments start with <code>//</code>:</p>
<pre><code class="hljs"><span class="hljs-comment">// This is a comment</span>
<span class="hljs-keyword">let</span> x = <span class="hljs-number">50</span>;  <span class="hljs-comment">// inline comment</span>
M x <span class="hljs-number">0</span>
</code></pre><h2>Path Context (ctx)</h2>
<p>When using <code>compileWithContext()</code>, a <code>ctx</code> object tracks the current drawing state:</p>
<pre><code class="hljs">M <span class="hljs-number">10</span> <span class="hljs-number">20</span>
L <span class="hljs-number">30</span> <span class="hljs-number">40</span>
L <span class="hljs-title function_">calc</span>(ctx.<span class="hljs-property">position</span>.<span class="hljs-property">x</span> + <span class="hljs-number">10</span>) ctx.<span class="hljs-property">position</span>.<span class="hljs-property">y</span>  <span class="hljs-comment">// L 40 40</span>
</code></pre><h3>ctx Properties</h3>
<table>
<thead>
<tr>
<th>Property</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>ctx.position.x</code></td>
<td>number</td>
<td>Current X coordinate</td>
</tr>
<tr>
<td><code>ctx.position.y</code></td>
<td>number</td>
<td>Current Y coordinate</td>
</tr>
<tr>
<td><code>ctx.start.x</code></td>
<td>number</td>
<td>Subpath start X (set by M, used by Z)</td>
</tr>
<tr>
<td><code>ctx.start.y</code></td>
<td>number</td>
<td>Subpath start Y</td>
</tr>
<tr>
<td><code>ctx.commands</code></td>
<td>array</td>
<td>History of executed commands</td>
</tr>
</tbody></table>
<h3>How Position Updates</h3>
<ul>
<li><strong>M/m</strong>: Sets position and subpath start</li>
<li><strong>L/l, H/h, V/v</strong>: Updates position to endpoint</li>
<li><strong>C/c, S/s, Q/q, T/t</strong>: Updates position to curve endpoint</li>
<li><strong>A/a</strong>: Updates position to arc endpoint</li>
<li><strong>Z/z</strong>: Returns to subpath start</li>
</ul>
<p>Lowercase (relative) commands add to current position; uppercase (absolute) set it directly.</p>
<h3>log() Function</h3>
<p>Use <code>log()</code> to inspect the context during evaluation:</p>
<pre><code class="hljs">M <span class="hljs-number">10</span> <span class="hljs-number">20</span>
<span class="hljs-title function_">log</span>(ctx)           <span class="hljs-comment">// Logs full context as JSON</span>
<span class="hljs-title function_">log</span>(ctx.<span class="hljs-property">position</span>)  <span class="hljs-comment">// Logs just position object</span>
<span class="hljs-title function_">log</span>(ctx.<span class="hljs-property">position</span>.<span class="hljs-property">x</span>) <span class="hljs-comment">// Logs just the x value</span>
L <span class="hljs-number">30</span> <span class="hljs-number">40</span>
</code></pre><p>The logs are captured in the <code>logs</code> array returned by <code>compileWithContext()</code>.</p>
<h3>Example: Drawing Relative to Current Position</h3>
<pre><code class="hljs">M <span class="hljs-number">100</span> <span class="hljs-number">100</span>
L <span class="hljs-number">150</span> <span class="hljs-number">150</span>
<span class="hljs-comment">// Continue from current position</span>
L <span class="hljs-title function_">calc</span>(ctx.<span class="hljs-property">position</span>.<span class="hljs-property">x</span> + <span class="hljs-number">50</span>) ctx.<span class="hljs-property">position</span>.<span class="hljs-property">y</span>
L ctx.<span class="hljs-property">position</span>.<span class="hljs-property">x</span> <span class="hljs-title function_">calc</span>(ctx.<span class="hljs-property">position</span>.<span class="hljs-property">y</span> + <span class="hljs-number">50</span>)
Z
</code></pre><h2>Complete Example</h2>
<pre><code class="hljs"><span class="hljs-comment">// Draw a grid of circles with varying sizes</span>
<span class="hljs-keyword">let</span> cols = <span class="hljs-number">5</span>;
<span class="hljs-keyword">let</span> rows = <span class="hljs-number">5</span>;
<span class="hljs-keyword">let</span> spacing = <span class="hljs-number">40</span>;

<span class="hljs-keyword">for</span> (row <span class="hljs-keyword">in</span> <span class="hljs-number">0.</span>.<span class="hljs-property">rows</span>) {
  <span class="hljs-keyword">for</span> (col <span class="hljs-keyword">in</span> <span class="hljs-number">0.</span>.<span class="hljs-property">cols</span>) {
    <span class="hljs-keyword">let</span> x = <span class="hljs-title function_">calc</span>(col * spacing + <span class="hljs-number">20</span>);
    <span class="hljs-keyword">let</span> y = <span class="hljs-title function_">calc</span>(row * spacing + <span class="hljs-number">20</span>);
    <span class="hljs-keyword">let</span> r = <span class="hljs-title function_">calc</span>(<span class="hljs-number">5</span> + col + row);
    <span class="hljs-title function_">circle</span>(x, y, r)
  }
}
</code></pre>`;

export const stdlib = `<h1>Standard Library Reference</h1>
<p>svg-path-extended includes built-in functions for math operations and common SVG shapes.</p>
<h2>Math Functions</h2>
<h3>Trigonometry</h3>
<p>All trigonometric functions use radians.</p>
<table>
<thead>
<tr>
<th>Function</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>sin(x)</code></td>
<td>Sine</td>
</tr>
<tr>
<td><code>cos(x)</code></td>
<td>Cosine</td>
</tr>
<tr>
<td><code>tan(x)</code></td>
<td>Tangent</td>
</tr>
<tr>
<td><code>asin(x)</code></td>
<td>Arc sine</td>
</tr>
<tr>
<td><code>acos(x)</code></td>
<td>Arc cosine</td>
</tr>
<tr>
<td><code>atan(x)</code></td>
<td>Arc tangent</td>
</tr>
<tr>
<td><code>atan2(y, x)</code></td>
<td>Two-argument arc tangent</td>
</tr>
</tbody></table>
<pre><code class="hljs"><span class="hljs-comment">// Draw a point on a circle</span>
<span class="hljs-keyword">let</span> angle = <span class="hljs-number">0.5</span>;
<span class="hljs-keyword">let</span> r = <span class="hljs-number">50</span>;
M <span class="hljs-title function_">calc</span>(<span class="hljs-number">100</span> + <span class="hljs-title function_">cos</span>(angle) * r) <span class="hljs-title function_">calc</span>(<span class="hljs-number">100</span> + <span class="hljs-title function_">sin</span>(angle) * r)
</code></pre><h3>Angle Conversion</h3>
<table>
<thead>
<tr>
<th>Function</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>rad(degrees)</code></td>
<td>Convert degrees to radians</td>
</tr>
<tr>
<td><code>deg(radians)</code></td>
<td>Convert radians to degrees</td>
</tr>
</tbody></table>
<pre><code class="hljs"><span class="hljs-comment">// Use degrees instead of radians</span>
<span class="hljs-keyword">let</span> angle = <span class="hljs-title function_">rad</span>(<span class="hljs-number">45</span>);
M <span class="hljs-title function_">calc</span>(<span class="hljs-title function_">cos</span>(angle) * <span class="hljs-number">50</span>) <span class="hljs-title function_">calc</span>(<span class="hljs-title function_">sin</span>(angle) * <span class="hljs-number">50</span>)
</code></pre><h3>Exponential &amp; Logarithmic</h3>
<table>
<thead>
<tr>
<th>Function</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>exp(x)</code></td>
<td>e raised to power x</td>
</tr>
<tr>
<td><code>log(x)</code></td>
<td>Natural logarithm</td>
</tr>
<tr>
<td><code>log10(x)</code></td>
<td>Base-10 logarithm</td>
</tr>
<tr>
<td><code>log2(x)</code></td>
<td>Base-2 logarithm</td>
</tr>
<tr>
<td><code>pow(x, y)</code></td>
<td>x raised to power y</td>
</tr>
<tr>
<td><code>sqrt(x)</code></td>
<td>Square root</td>
</tr>
<tr>
<td><code>cbrt(x)</code></td>
<td>Cube root</td>
</tr>
</tbody></table>
<h3>Rounding</h3>
<table>
<thead>
<tr>
<th>Function</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>floor(x)</code></td>
<td>Round down</td>
</tr>
<tr>
<td><code>ceil(x)</code></td>
<td>Round up</td>
</tr>
<tr>
<td><code>round(x)</code></td>
<td>Round to nearest integer</td>
</tr>
<tr>
<td><code>trunc(x)</code></td>
<td>Truncate decimal part</td>
</tr>
</tbody></table>
<h3>Utility</h3>
<table>
<thead>
<tr>
<th>Function</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>abs(x)</code></td>
<td>Absolute value</td>
</tr>
<tr>
<td><code>sign(x)</code></td>
<td>Sign (-1, 0, or 1)</td>
</tr>
<tr>
<td><code>min(a, b, ...)</code></td>
<td>Minimum value</td>
</tr>
<tr>
<td><code>max(a, b, ...)</code></td>
<td>Maximum value</td>
</tr>
</tbody></table>
<h3>Interpolation &amp; Clamping</h3>
<table>
<thead>
<tr>
<th>Function</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>lerp(a, b, t)</code></td>
<td>Linear interpolation: <code>a + (b - a) * t</code></td>
</tr>
<tr>
<td><code>clamp(value, min, max)</code></td>
<td>Constrain value to range</td>
</tr>
<tr>
<td><code>map(value, inMin, inMax, outMin, outMax)</code></td>
<td>Map value from one range to another</td>
</tr>
</tbody></table>
<pre><code class="hljs"><span class="hljs-comment">// Interpolate between two positions</span>
<span class="hljs-keyword">let</span> t = <span class="hljs-number">0.5</span>;
M <span class="hljs-title function_">calc</span>(<span class="hljs-title function_">lerp</span>(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>, t)) <span class="hljs-title function_">calc</span>(<span class="hljs-title function_">lerp</span>(<span class="hljs-number">0</span>, <span class="hljs-number">50</span>, t))

<span class="hljs-comment">// Clamp a value</span>
<span class="hljs-keyword">let</span> x = <span class="hljs-title function_">clamp</span>(<span class="hljs-number">150</span>, <span class="hljs-number">0</span>, <span class="hljs-number">100</span>);  <span class="hljs-comment">// Result: 100</span>
</code></pre><h3>Constants</h3>
<table>
<thead>
<tr>
<th>Function</th>
<th>Returns</th>
</tr>
</thead>
<tbody><tr>
<td><code>PI()</code></td>
<td>3.14159...</td>
</tr>
<tr>
<td><code>E()</code></td>
<td>2.71828...</td>
</tr>
<tr>
<td><code>TAU()</code></td>
<td>6.28318... (2π)</td>
</tr>
<tr>
<td><code>mpi(x)</code></td>
<td><code>x * π</code> (multiply by π)</td>
</tr>
</tbody></table>
<pre><code class="hljs"><span class="hljs-comment">// Draw a semicircle</span>
<span class="hljs-keyword">let</span> r = <span class="hljs-number">50</span>;
<span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">0.</span><span class="hljs-number">.20</span>) {
  <span class="hljs-keyword">let</span> angle = <span class="hljs-title function_">calc</span>(i / <span class="hljs-number">20</span> * <span class="hljs-title function_">PI</span>());
  L <span class="hljs-title function_">calc</span>(<span class="hljs-number">100</span> + <span class="hljs-title function_">cos</span>(angle) * r) <span class="hljs-title function_">calc</span>(<span class="hljs-number">100</span> + <span class="hljs-title function_">sin</span>(angle) * r)
}
</code></pre><h3>Random</h3>
<table>
<thead>
<tr>
<th>Function</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>random()</code></td>
<td>Random number between 0 and 1</td>
</tr>
<tr>
<td><code>randomRange(min, max)</code></td>
<td>Random number in range</td>
</tr>
</tbody></table>
<p><strong>Note</strong>: Random functions are not deterministic. Each call produces a different value.</p>
<hr>
<h2>Path Functions</h2>
<p>These functions generate complete path segments.</p>
<h3>circle(cx, cy, r)</h3>
<p>Draws a circle centered at (cx, cy) with radius r.</p>
<pre><code class="hljs"><span class="hljs-title function_">circle</span>(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">50</span>)
</code></pre><p>Output: A full circle using two arc commands.</p>
<h3>rect(x, y, width, height)</h3>
<p>Draws a rectangle.</p>
<pre><code class="hljs"><span class="hljs-title function_">rect</span>(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">80</span>, <span class="hljs-number">60</span>)
</code></pre><h3>roundRect(x, y, width, height, radius)</h3>
<p>Draws a rectangle with rounded corners.</p>
<pre><code class="hljs">roundRect(10, 10, 80, 60, 10)
</code></pre><h3>polygon(cx, cy, radius, sides)</h3>
<p>Draws a regular polygon.</p>
<pre><code class="hljs"><span class="hljs-title function_">polygon</span>(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">50</span>, <span class="hljs-number">6</span>)  <span class="hljs-comment">// Hexagon</span>
<span class="hljs-title function_">polygon</span>(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">50</span>, <span class="hljs-number">8</span>)  <span class="hljs-comment">// Octagon</span>
</code></pre><h3>star(cx, cy, outerRadius, innerRadius, points)</h3>
<p>Draws a star shape.</p>
<pre><code class="hljs"><span class="hljs-title function_">star</span>(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">50</span>, <span class="hljs-number">25</span>, <span class="hljs-number">5</span>)  <span class="hljs-comment">// 5-pointed star</span>
</code></pre><h3>line(x1, y1, x2, y2)</h3>
<p>Draws a line segment.</p>
<pre><code class="hljs">line(0, 0, 100, 100)
</code></pre><h3>arc(rx, ry, rotation, largeArc, sweep, x, y)</h3>
<p>Draws an arc to (x, y). This is a direct wrapper around the SVG <code>A</code> command.</p>
<pre><code class="hljs">M <span class="hljs-number">50</span> <span class="hljs-number">100</span>
<span class="hljs-title function_">arc</span>(<span class="hljs-number">50</span>, <span class="hljs-number">50</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">150</span>, <span class="hljs-number">100</span>)
</code></pre><h3>quadratic(x1, y1, cx, cy, x2, y2)</h3>
<p>Draws a quadratic bezier curve from (x1, y1) to (x2, y2) with control point (cx, cy).</p>
<pre><code class="hljs">quadratic(0, 100, 50, 0, 100, 100)
</code></pre><h3>cubic(x1, y1, c1x, c1y, c2x, c2y, x2, y2)</h3>
<p>Draws a cubic bezier curve.</p>
<pre><code class="hljs">cubic(0, 100, 25, 0, 75, 0, 100, 100)
</code></pre><h3>moveTo(x, y)</h3>
<p>Returns a move command. Useful inside functions.</p>
<pre><code class="hljs">moveTo(50, 50)
</code></pre><h3>lineTo(x, y)</h3>
<p>Returns a line command.</p>
<pre><code class="hljs">lineTo(100, 100)
</code></pre><h3>closePath()</h3>
<p>Returns a close path command.</p>
<pre><code class="hljs">closePath()
</code></pre><hr>
<h2>Context-Aware Functions</h2>
<p>These functions use the current path context (position, tangent direction) to generate path segments. They maintain path continuity and are ideal for building complex shapes programmatically.</p>
<h3>Polar Movement</h3>
<h4>polarPoint(angle, distance)</h4>
<p>Returns a point at a polar offset from current position. Does not emit any path commands.</p>
<pre><code class="hljs">M <span class="hljs-number">100</span> <span class="hljs-number">100</span>
<span class="hljs-keyword">let</span> p = <span class="hljs-title function_">polarPoint</span>(<span class="hljs-number">0</span>, <span class="hljs-number">50</span>);
L p.<span class="hljs-property">x</span> p.<span class="hljs-property">y</span>  <span class="hljs-comment">// Line to (150, 100)</span>
</code></pre><h4>polarOffset(angle, distance)</h4>
<p>Returns <code>{x, y}</code> coordinates at a polar offset. Similar to <code>polarPoint</code>.</p>
<h4>polarMove(angle, distance)</h4>
<p>Emits a line command (<code>L</code>) moving in the specified direction. Updates position but draws a visible line.</p>
<pre><code class="hljs">M <span class="hljs-number">100</span> <span class="hljs-number">100</span>
<span class="hljs-title function_">polarMove</span>(<span class="hljs-number">0</span>, <span class="hljs-number">50</span>)  <span class="hljs-comment">// Draws line to (150, 100)</span>
</code></pre><h4>polarLine(angle, distance)</h4>
<p>Emits a line command (<code>L</code>) in the specified direction. Same as <code>polarMove</code>.</p>
<pre><code class="hljs">M <span class="hljs-number">100</span> <span class="hljs-number">100</span>
<span class="hljs-title function_">polarLine</span>(45deg, <span class="hljs-number">70.7</span>)  <span class="hljs-comment">// Draws line diagonally</span>
</code></pre><h3>Arc Functions</h3>
<h4>arcFromCenter(dcx, dcy, radius, startAngle, endAngle, clockwise)</h4>
<p>Draws an arc defined by center offset and angles. Returns <code>{point, angle}</code> with endpoint and tangent.</p>
<ul>
<li><code>dcx, dcy</code>: Offset from current position to arc center</li>
<li><code>radius</code>: Arc radius</li>
<li><code>startAngle, endAngle</code>: Start and end angles in radians</li>
<li><code>clockwise</code>: 1 for clockwise, 0 for counter-clockwise</li>
</ul>
<p><strong>Warning:</strong> If current position doesn&#39;t match the calculated arc start point, a line segment (<code>L</code>) will be drawn to the arc start. For guaranteed continuous arcs, use <code>arcFromPolarOffset</code>.</p>
<pre><code class="hljs">M <span class="hljs-number">50</span> <span class="hljs-number">50</span>
<span class="hljs-title function_">arcFromCenter</span>(<span class="hljs-number">50</span>, <span class="hljs-number">0</span>, <span class="hljs-number">50</span>, 180deg, 270deg, <span class="hljs-number">1</span>)
<span class="hljs-comment">// Center at (100, 50), arc from (50, 50) to (100, 100)</span>
</code></pre><h4>arcFromPolarOffset(angle, radius, angleOfArc)</h4>
<p>Draws an arc where the center is at a polar offset from current position. The current position is guaranteed to be on the circle, so only an <code>A</code> command is emitted (no <code>M</code> or <code>L</code>). Returns <code>{point, angle}</code> with endpoint and tangent.</p>
<ul>
<li><code>angle</code>: Direction from current position to arc center (radians)</li>
<li><code>radius</code>: Arc radius</li>
<li><code>angleOfArc</code>: Sweep angle (positive = clockwise, negative = counter-clockwise)</li>
</ul>
<p>This function is ideal for creating continuous curved paths because it never emits extra line segments.</p>
<pre><code class="hljs">M <span class="hljs-number">100</span> <span class="hljs-number">100</span>
<span class="hljs-title function_">arcFromPolarOffset</span>(<span class="hljs-number">0</span>, <span class="hljs-number">50</span>, 90deg)
<span class="hljs-comment">// Center at (150, 100), sweeps 90° clockwise</span>
<span class="hljs-comment">// Ends at (150, 50)</span>
</code></pre><p><strong>Comparison with arcFromCenter:</strong></p>
<table>
<thead>
<tr>
<th>Aspect</th>
<th>arcFromCenter</th>
<th>arcFromPolarOffset</th>
</tr>
</thead>
<tbody><tr>
<td>Center defined by</td>
<td>Offset from current position</td>
<td>Polar direction from current position</td>
</tr>
<tr>
<td>Start point</td>
<td>Calculated from startAngle</td>
<td>Current position (guaranteed)</td>
</tr>
<tr>
<td>May emit L command</td>
<td>Yes, if position doesn&#39;t match</td>
<td>Never</td>
</tr>
<tr>
<td>Best for</td>
<td>Arcs with known center offset</td>
<td>Continuous curved paths</td>
</tr>
</tbody></table>
<h3>Tangent Functions</h3>
<p>These functions continue from the previous arc or polar command&#39;s direction.</p>
<h4>tangentLine(length)</h4>
<p>Draws a line continuing in the tangent direction from the previous arc or polar command.</p>
<pre><code class="hljs"><span class="hljs-title function_">arcFromPolarOffset</span>(<span class="hljs-number">0</span>, <span class="hljs-number">50</span>, 90deg)
<span class="hljs-title function_">tangentLine</span>(<span class="hljs-number">30</span>)  <span class="hljs-comment">// Continues in the arc&#x27;s exit direction</span>
</code></pre><h4>tangentArc(radius, sweepAngle)</h4>
<p>Draws an arc continuing tangent to the previous arc or polar command.</p>
<pre><code class="hljs"><span class="hljs-title function_">arcFromPolarOffset</span>(<span class="hljs-number">0</span>, <span class="hljs-number">50</span>, 90deg)
<span class="hljs-title function_">tangentArc</span>(<span class="hljs-number">30</span>, 45deg)  <span class="hljs-comment">// Smooth continuation with a smaller arc</span>
</code></pre><hr>
<h2>Using Functions Inside calc()</h2>
<p>Math functions can be used inside <code>calc()</code>:</p>
<pre><code class="hljs">M <span class="hljs-title function_">calc</span>(<span class="hljs-title function_">sin</span>(<span class="hljs-number">0.5</span>) * <span class="hljs-number">100</span>) <span class="hljs-title function_">calc</span>(<span class="hljs-title function_">cos</span>(<span class="hljs-number">0.5</span>) * <span class="hljs-number">100</span>)
L <span class="hljs-title function_">calc</span>(<span class="hljs-title function_">lerp</span>(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>, <span class="hljs-number">0.5</span>)) <span class="hljs-title function_">calc</span>(<span class="hljs-title function_">clamp</span>(<span class="hljs-number">150</span>, <span class="hljs-number">0</span>, <span class="hljs-number">100</span>))
</code></pre><p>Path functions are called at the statement level:</p>
<pre><code class="hljs"><span class="hljs-title function_">circle</span>(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-title function_">calc</span>(<span class="hljs-number">25</span> + <span class="hljs-number">25</span>))  <span class="hljs-comment">// calc() inside arguments</span>
</code></pre>`;

export const layers = `<h1>Layers</h1>
<p>Layers let you output multiple <code>&lt;path&gt;</code> elements from a single program, each with its own styles and independent pen tracking.</p>
<h2>Defining Layers</h2>
<p>Use <code>define</code> to create a named layer with a style block:</p>
<pre><code class="hljs">define PathLayer(<span class="hljs-string">&#x27;outline&#x27;</span>) <span class="hljs-variable">\${
  stroke: #cc0000;
  stroke-width: 3;
  fill: none;
}</span>
</code></pre><p>Layer names must be unique strings. The style block uses CSS/SVG property syntax — any SVG presentation attribute works (<code>stroke</code>, <code>fill</code>, <code>opacity</code>, <code>stroke-dasharray</code>, etc.).</p>
<blockquote>
<p><strong>Breaking change:</strong> Style blocks now use <code>\${ }</code> syntax instead of <code>{ }</code>. Update existing layer definitions: <code>{ stroke: red; }</code> → <code>\${ stroke: red; }</code>.</p>
</blockquote>
<h3>Default Layer</h3>
<p>Mark one layer as <code>default</code> to receive all bare path commands (commands outside any <code>layer().apply</code> block):</p>
<pre><code class="hljs">define <span class="hljs-keyword">default</span> <span class="hljs-title class_">PathLayer</span>(<span class="hljs-string">&#x27;main&#x27;</span>) \${
  <span class="hljs-attr">stroke</span>: #<span class="hljs-number">333</span>;
  stroke-<span class="hljs-attr">width</span>: <span class="hljs-number">2</span>;
  <span class="hljs-attr">fill</span>: none;
}

<span class="hljs-comment">// These commands go to &#x27;main&#x27; automatically</span>
M <span class="hljs-number">10</span> <span class="hljs-number">10</span>
L <span class="hljs-number">90</span> <span class="hljs-number">10</span>
L <span class="hljs-number">90</span> <span class="hljs-number">90</span>
Z
</code></pre><p>Without a default layer, bare commands go to an implicit unnamed layer.</p>
<h2>Writing to Layers</h2>
<p>Use <code>layer(&#39;name&#39;).apply { ... }</code> to send commands to a specific layer:</p>
<pre><code class="hljs">define <span class="hljs-title class_">PathLayer</span>(<span class="hljs-string">&#x27;grid&#x27;</span>) \${
  <span class="hljs-attr">stroke</span>: #ddd;
  stroke-<span class="hljs-attr">width</span>: <span class="hljs-number">0.5</span>;
}

define <span class="hljs-keyword">default</span> <span class="hljs-title class_">PathLayer</span>(<span class="hljs-string">&#x27;shape&#x27;</span>) \${
  <span class="hljs-attr">stroke</span>: #<span class="hljs-number">333</span>;
  stroke-<span class="hljs-attr">width</span>: <span class="hljs-number">2</span>;
  <span class="hljs-attr">fill</span>: none;
}

<span class="hljs-comment">// Draw a grid on the &#x27;grid&#x27; layer</span>
<span class="hljs-title function_">layer</span>(<span class="hljs-string">&#x27;grid&#x27;</span>).<span class="hljs-property">apply</span> {
  <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">0.</span><span class="hljs-number">.10</span>) {
    M <span class="hljs-title function_">calc</span>(i * <span class="hljs-number">20</span>) <span class="hljs-number">0</span>
    V <span class="hljs-number">200</span>
    M <span class="hljs-number">0</span> <span class="hljs-title function_">calc</span>(i * <span class="hljs-number">20</span>)
    H <span class="hljs-number">200</span>
  }
}

<span class="hljs-comment">// These go to &#x27;shape&#x27; (the default)</span>
M <span class="hljs-number">40</span> <span class="hljs-number">40</span>
L <span class="hljs-number">160</span> <span class="hljs-number">40</span>
L <span class="hljs-number">100</span> <span class="hljs-number">160</span>
Z
</code></pre><h3>Context Isolation</h3>
<p>Each layer has its own pen position. Commands in one layer don&#39;t affect another layer&#39;s <code>ctx</code>:</p>
<pre><code class="hljs">define <span class="hljs-keyword">default</span> <span class="hljs-title class_">PathLayer</span>(<span class="hljs-string">&#x27;a&#x27;</span>) \${ <span class="hljs-attr">stroke</span>: red; }
define <span class="hljs-title class_">PathLayer</span>(<span class="hljs-string">&#x27;b&#x27;</span>) \${ <span class="hljs-attr">stroke</span>: blue; }

M <span class="hljs-number">100</span> <span class="hljs-number">100</span>    <span class="hljs-comment">// layer &#x27;a&#x27; position: (100, 100)</span>

<span class="hljs-title function_">layer</span>(<span class="hljs-string">&#x27;b&#x27;</span>).<span class="hljs-property">apply</span> {
  M <span class="hljs-number">50</span> <span class="hljs-number">50</span>    <span class="hljs-comment">// layer &#x27;b&#x27; position: (50, 50)</span>
}

<span class="hljs-comment">// Back in layer &#x27;a&#x27;, position is still (100, 100)</span>
L <span class="hljs-number">200</span> <span class="hljs-number">200</span>
</code></pre><h2>Accessing Layer Context</h2>
<p>Use <code>layer(&#39;name&#39;).ctx</code> to read a layer&#39;s pen state from anywhere:</p>
<pre><code class="hljs">define <span class="hljs-keyword">default</span> <span class="hljs-title class_">PathLayer</span>(<span class="hljs-string">&#x27;main&#x27;</span>) \${ <span class="hljs-attr">stroke</span>: #<span class="hljs-number">333</span>; }
define <span class="hljs-title class_">PathLayer</span>(<span class="hljs-string">&#x27;markers&#x27;</span>) \${ <span class="hljs-attr">stroke</span>: red; <span class="hljs-attr">fill</span>: red; }

M <span class="hljs-number">50</span> <span class="hljs-number">50</span>
L <span class="hljs-number">150</span> <span class="hljs-number">80</span>
L <span class="hljs-number">100</span> <span class="hljs-number">150</span>

<span class="hljs-comment">// Draw markers at the main layer&#x27;s current position</span>
<span class="hljs-title function_">layer</span>(<span class="hljs-string">&#x27;markers&#x27;</span>).<span class="hljs-property">apply</span> {
  <span class="hljs-keyword">let</span> px = <span class="hljs-title function_">layer</span>(<span class="hljs-string">&#x27;main&#x27;</span>).<span class="hljs-property">ctx</span>.<span class="hljs-property">position</span>.<span class="hljs-property">x</span>
  <span class="hljs-keyword">let</span> py = <span class="hljs-title function_">layer</span>(<span class="hljs-string">&#x27;main&#x27;</span>).<span class="hljs-property">ctx</span>.<span class="hljs-property">position</span>.<span class="hljs-property">y</span>
  <span class="hljs-title function_">circle</span>(px, py, <span class="hljs-number">4</span>)
}
</code></pre><p>Available context properties:</p>
<table>
<thead>
<tr>
<th>Expression</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>layer(&#39;name&#39;).ctx.position.x</code></td>
<td>Current X position</td>
</tr>
<tr>
<td><code>layer(&#39;name&#39;).ctx.position.y</code></td>
<td>Current Y position</td>
</tr>
<tr>
<td><code>layer(&#39;name&#39;).ctx.start.x</code></td>
<td>Subpath start X</td>
</tr>
<tr>
<td><code>layer(&#39;name&#39;).ctx.start.y</code></td>
<td>Subpath start Y</td>
</tr>
<tr>
<td><code>layer(&#39;name&#39;).name</code></td>
<td>Layer name string</td>
</tr>
</tbody></table>
<h2>Dynamic Layer Names</h2>
<p>Layer names can be expressions, including variables:</p>
<pre><code class="hljs"><span class="hljs-keyword">let</span> target = <span class="hljs-string">&#x27;overlay&#x27;</span>
define <span class="hljs-title class_">PathLayer</span>(target) \${ <span class="hljs-attr">stroke</span>: blue; }

<span class="hljs-title function_">layer</span>(target).<span class="hljs-property">apply</span> {
  M <span class="hljs-number">0</span> <span class="hljs-number">0</span> L <span class="hljs-number">100</span> <span class="hljs-number">100</span>
}
</code></pre><h2>Style Properties</h2>
<p>Style properties map directly to SVG presentation attributes. Common properties:</p>
<table>
<thead>
<tr>
<th>Property</th>
<th>Example</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>stroke</code></td>
<td><code>#cc0000</code></td>
<td>Stroke color</td>
</tr>
<tr>
<td><code>stroke-width</code></td>
<td><code>3</code></td>
<td>Stroke width</td>
</tr>
<tr>
<td><code>stroke-linecap</code></td>
<td><code>round</code></td>
<td>Line cap style</td>
</tr>
<tr>
<td><code>stroke-linejoin</code></td>
<td><code>round</code></td>
<td>Line join style</td>
</tr>
<tr>
<td><code>stroke-dasharray</code></td>
<td><code>4 2</code></td>
<td>Dash pattern</td>
</tr>
<tr>
<td><code>stroke-dashoffset</code></td>
<td><code>1</code></td>
<td>Dash offset</td>
</tr>
<tr>
<td><code>stroke-opacity</code></td>
<td><code>0.5</code></td>
<td>Stroke opacity</td>
</tr>
<tr>
<td><code>fill</code></td>
<td><code>none</code></td>
<td>Fill color</td>
</tr>
<tr>
<td><code>fill-opacity</code></td>
<td><code>0.3</code></td>
<td>Fill opacity</td>
</tr>
<tr>
<td><code>opacity</code></td>
<td><code>0.8</code></td>
<td>Overall opacity</td>
</tr>
</tbody></table>
<p>Each property is a semicolon-terminated declaration:</p>
<pre><code class="hljs">define PathLayer(<span class="hljs-string">&#x27;dashed&#x27;</span>) <span class="hljs-variable">\${
  stroke: #0066cc;
  stroke-width: 2;
  stroke-dasharray: 8 4;
  fill: none;
}</span>
</code></pre><h2>Output Format</h2>
<p>When using the JavaScript API, <code>compile()</code> returns a structured result:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { compile } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;svg-path-extended&#x27;</span>;

<span class="hljs-keyword">const</span> result = <span class="hljs-title function_">compile</span>(<span class="hljs-string">\`
  define default PathLayer(&#x27;bg&#x27;) <span class="hljs-subst">\${
    stroke: #ddd;
    fill: none;
  }</span>
  define PathLayer(&#x27;fg&#x27;) <span class="hljs-subst">\${
    stroke: #<span class="hljs-number">333</span>;
    stroke-width: <span class="hljs-number">2</span>;
    fill: none;
  }</span>

  M 0 0 H 100 V 100 H 0 Z

  layer(&#x27;fg&#x27;).apply {
    M 20 20 L 80 80
  }
\`</span>);

<span class="hljs-comment">// result.layers is an array of LayerOutput:</span>
<span class="hljs-comment">// [</span>
<span class="hljs-comment">//   {</span>
<span class="hljs-comment">//     name: &#x27;bg&#x27;,</span>
<span class="hljs-comment">//     type: &#x27;path&#x27;,</span>
<span class="hljs-comment">//     data: &#x27;M 0 0 H 100 V 100 H 0 Z&#x27;,</span>
<span class="hljs-comment">//     styles: { stroke: &#x27;#ddd&#x27;, fill: &#x27;none&#x27; },</span>
<span class="hljs-comment">//     isDefault: true</span>
<span class="hljs-comment">//   },</span>
<span class="hljs-comment">//   {</span>
<span class="hljs-comment">//     name: &#x27;fg&#x27;,</span>
<span class="hljs-comment">//     type: &#x27;path&#x27;,</span>
<span class="hljs-comment">//     data: &#x27;M 20 20 L 80 80&#x27;,</span>
<span class="hljs-comment">//     styles: { stroke: &#x27;#333&#x27;, &#x27;stroke-width&#x27;: &#x27;2&#x27;, fill: &#x27;none&#x27; },</span>
<span class="hljs-comment">//     isDefault: false</span>
<span class="hljs-comment">//   }</span>
<span class="hljs-comment">// ]</span>
</code></pre><p>Programs without any <code>define</code> statements produce a single implicit layer:</p>
<pre><code class="hljs language-js"><span class="hljs-title function_">compile</span>(<span class="hljs-string">&#x27;M 0 0 L 100 100&#x27;</span>).<span class="hljs-property">layers</span>
<span class="hljs-comment">// [{ name: &#x27;default&#x27;, type: &#x27;path&#x27;, data: &#x27;M 0 0 L 100 100&#x27;, styles: {}, isDefault: true }]</span>
</code></pre><h2>Full Example</h2>
<p>A multi-layer illustration with a background grid, main shape, and annotation markers:</p>
<pre><code class="hljs"><span class="hljs-comment">// Layer definitions</span>
define <span class="hljs-title class_">PathLayer</span>(<span class="hljs-string">&#x27;grid&#x27;</span>) \${
  <span class="hljs-attr">stroke</span>: #e0e0e0;
  stroke-<span class="hljs-attr">width</span>: <span class="hljs-number">0.5</span>;
}

define <span class="hljs-keyword">default</span> <span class="hljs-title class_">PathLayer</span>(<span class="hljs-string">&#x27;shape&#x27;</span>) \${
  <span class="hljs-attr">stroke</span>: #<span class="hljs-number">333333</span>;
  stroke-<span class="hljs-attr">width</span>: <span class="hljs-number">2</span>;
  <span class="hljs-attr">fill</span>: none;
  stroke-<span class="hljs-attr">linejoin</span>: round;
}

define <span class="hljs-title class_">PathLayer</span>(<span class="hljs-string">&#x27;points&#x27;</span>) \${
  <span class="hljs-attr">stroke</span>: #cc0000;
  <span class="hljs-attr">fill</span>: #cc0000;
}

<span class="hljs-comment">// Grid</span>
<span class="hljs-title function_">layer</span>(<span class="hljs-string">&#x27;grid&#x27;</span>).<span class="hljs-property">apply</span> {
  <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">0.</span><span class="hljs-number">.10</span>) {
    M <span class="hljs-title function_">calc</span>(i * <span class="hljs-number">20</span>) <span class="hljs-number">0</span>  V <span class="hljs-number">200</span>
    M <span class="hljs-number">0</span> <span class="hljs-title function_">calc</span>(i * <span class="hljs-number">20</span>)  H <span class="hljs-number">200</span>
  }
}

<span class="hljs-comment">// Shape (goes to default layer)</span>
<span class="hljs-keyword">let</span> cx = <span class="hljs-number">100</span>
<span class="hljs-keyword">let</span> cy = <span class="hljs-number">100</span>
<span class="hljs-keyword">let</span> r = <span class="hljs-number">60</span>
<span class="hljs-keyword">let</span> sides = <span class="hljs-number">6</span>

<span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">0.</span>.<span class="hljs-property">sides</span>) {
  <span class="hljs-keyword">let</span> angle = <span class="hljs-title function_">calc</span>(i * <span class="hljs-number">360</span> / sides - <span class="hljs-number">90</span>)
  <span class="hljs-keyword">let</span> x = <span class="hljs-title function_">calc</span>(cx + r * <span class="hljs-title function_">cos</span>(<span class="hljs-title function_">radians</span>(angle)))
  <span class="hljs-keyword">let</span> y = <span class="hljs-title function_">calc</span>(cy + r * <span class="hljs-title function_">sin</span>(<span class="hljs-title function_">radians</span>(angle)))
  <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) { M x y } <span class="hljs-keyword">else</span> { L x y }
}
Z

<span class="hljs-comment">// Mark each vertex</span>
<span class="hljs-title function_">layer</span>(<span class="hljs-string">&#x27;points&#x27;</span>).<span class="hljs-property">apply</span> {
  <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">0.</span>.<span class="hljs-property">sides</span>) {
    <span class="hljs-keyword">let</span> angle = <span class="hljs-title function_">calc</span>(i * <span class="hljs-number">360</span> / sides - <span class="hljs-number">90</span>)
    <span class="hljs-keyword">let</span> x = <span class="hljs-title function_">calc</span>(cx + r * <span class="hljs-title function_">cos</span>(<span class="hljs-title function_">radians</span>(angle)))
    <span class="hljs-keyword">let</span> y = <span class="hljs-title function_">calc</span>(cy + r * <span class="hljs-title function_">sin</span>(<span class="hljs-title function_">radians</span>(angle)))
    <span class="hljs-title function_">circle</span>(x, y, <span class="hljs-number">3</span>)
  }
}
</code></pre><h2>TextLayer</h2>
<p>TextLayers produce SVG <code>&lt;text&gt;</code> elements instead of <code>&lt;path&gt;</code> elements.</p>
<h3>Defining a TextLayer</h3>
<pre><code class="hljs">define TextLayer(<span class="hljs-string">&#x27;labels&#x27;</span>) <span class="hljs-variable">\${
  font-size: 14;
  font-family: monospace;
  fill: #333;
}</span>
</code></pre><h3>text() — Two Forms</h3>
<p><strong>Inline form</strong> — simple text content:</p>
<pre><code class="hljs"><span class="hljs-title function_">layer</span>(<span class="hljs-string">&#x27;labels&#x27;</span>).<span class="hljs-property">apply</span> {
  <span class="hljs-title function_">text</span>(<span class="hljs-number">50</span>, <span class="hljs-number">45</span>)<span class="hljs-string">\`Start\`</span>
  <span class="hljs-title function_">text</span>(<span class="hljs-number">150</span>, <span class="hljs-number">75</span>, 30deg)<span class="hljs-string">\`End\`</span>    <span class="hljs-comment">// rotation uses angle units (deg/rad/pi)</span>
}
</code></pre><p><strong>Block form</strong> — mixed text runs and tspan children:</p>
<pre><code class="hljs"><span class="hljs-title function_">layer</span>(<span class="hljs-string">&#x27;labels&#x27;</span>).<span class="hljs-property">apply</span> {
  <span class="hljs-title function_">text</span>(<span class="hljs-params"><span class="hljs-number">10</span>, <span class="hljs-number">180</span></span>) {
    <span class="hljs-string">\`Hello \`</span>
    <span class="hljs-title function_">tspan</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, 30deg)<span class="hljs-string">\`world\`</span>
    <span class="hljs-string">\` and more\`</span>
  }
}
</code></pre><p>The block form maps to SVG&#39;s mixed content model:
<code>&lt;text x=&quot;10&quot; y=&quot;180&quot;&gt;Hello &lt;tspan rotate=&quot;30&quot;&gt;world&lt;/tspan&gt; and more&lt;/text&gt;</code></p>
<p>Note: <code>30deg</code> in the source becomes <code>rotate=&quot;30&quot;</code> (degrees) in SVG output.</p>
<h3>tspan() — Only Inside text() Blocks</h3>
<pre><code class="hljs"><span class="hljs-title function_">tspan</span>()<span class="hljs-string">\`content\`</span>                   <span class="hljs-comment">// no offset</span>
<span class="hljs-title function_">tspan</span>(dx, dy)<span class="hljs-string">\`content\`</span>             <span class="hljs-comment">// with offsets</span>
<span class="hljs-title function_">tspan</span>(dx, dy, 45deg)<span class="hljs-string">\`content\`</span>      <span class="hljs-comment">// with offsets and rotation</span>
</code></pre><p>Position arguments (x, y, dx, dy) are plain numbers. Rotation follows the standard angle unit convention — bare numbers are radians, use <code>deg</code>/<code>rad</code>/<code>pi</code> suffixes for explicit units. Content is always a template literal.</p>
<h3>Template Literals</h3>
<p>Template literals use backtick syntax with <code>\${expression}</code> interpolation. They work everywhere — text content, log messages, variable values:</p>
<pre><code class="hljs"><span class="hljs-keyword">let</span> name = <span class="hljs-string">&quot;World&quot;</span>
<span class="hljs-keyword">let</span> x = <span class="hljs-string">\`Hello <span class="hljs-subst">\${name}</span>!\`</span>              <span class="hljs-comment">// &quot;Hello World!&quot;</span>
<span class="hljs-keyword">let</span> msg = <span class="hljs-string">\`Score: <span class="hljs-subst">\${<span class="hljs-number">2</span> + <span class="hljs-number">3</span>}</span>\`</span>           <span class="hljs-comment">// &quot;Score: 5&quot;</span>
<span class="hljs-title function_">log</span>(<span class="hljs-string">\`Position: <span class="hljs-subst">\${ctx.position.x}</span>\`</span>)    <span class="hljs-comment">// in log messages</span>
</code></pre><p>Template literals are the sole string construction mechanism — <code>+</code> stays strictly numeric. String equality (<code>==</code>/<code>!=</code>) works for conditionals:</p>
<pre><code class="hljs"><span class="hljs-keyword">let</span> mode = <span class="hljs-string">&quot;dark&quot;</span>
<span class="hljs-keyword">if</span> (mode == <span class="hljs-string">&quot;dark&quot;</span>) { <span class="hljs-comment">/* ... */</span> }
<span class="hljs-keyword">if</span> (mode != <span class="hljs-string">&quot;light&quot;</span>) { <span class="hljs-comment">/* ... */</span> }
</code></pre><h3>TextLayer Output Format</h3>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> result = <span class="hljs-title function_">compile</span>(<span class="hljs-string">\`
  define TextLayer(&#x27;labels&#x27;) <span class="hljs-subst">\${ font-size: <span class="hljs-number">14</span>; fill: #<span class="hljs-number">333</span>; }</span>
  layer(&#x27;labels&#x27;).apply {
    text(50, 45)\\\`Start\\\`
    text(10, 180) {
      tspan()\\\`Multi-\\\`
      tspan(0, 16)\\\`line\\\`
    }
  }
\`</span>);

<span class="hljs-comment">// result.layers[0]:</span>
<span class="hljs-comment">// {</span>
<span class="hljs-comment">//   name: &#x27;labels&#x27;,</span>
<span class="hljs-comment">//   type: &#x27;text&#x27;,</span>
<span class="hljs-comment">//   data: &#x27;Start Multi-line&#x27;,</span>
<span class="hljs-comment">//   textElements: [</span>
<span class="hljs-comment">//     { x: 50, y: 45, children: [{ type: &#x27;run&#x27;, text: &#x27;Start&#x27; }] },</span>
<span class="hljs-comment">//     { x: 10, y: 180, children: [</span>
<span class="hljs-comment">//       { type: &#x27;tspan&#x27;, text: &#x27;Multi-&#x27; },</span>
<span class="hljs-comment">//       { type: &#x27;tspan&#x27;, text: &#x27;line&#x27;, dx: 0, dy: 16 },</span>
<span class="hljs-comment">//     ]},</span>
<span class="hljs-comment">//   ],</span>
<span class="hljs-comment">//   styles: { &#x27;font-size&#x27;: &#x27;14&#x27;, fill: &#x27;#333&#x27; },</span>
<span class="hljs-comment">//   isDefault: false,</span>
<span class="hljs-comment">// }</span>
</code></pre><h3>Restrictions</h3>
<ul>
<li><code>text()</code> can only be used inside a <code>layer().apply</code> block targeting a TextLayer</li>
<li><code>tspan()</code> can only appear inside a <code>text() { }</code> block</li>
<li>Path commands (<code>M</code>, <code>L</code>, etc.) cannot be used inside a TextLayer apply block</li>
<li>If a TextLayer is the default layer, bare path commands will throw an error</li>
</ul>
<h2>Style Blocks</h2>
<p>Style blocks are first-class values that can be stored in variables, merged, and accessed via dot notation.</p>
<h3>Style Block Literals</h3>
<pre><code class="hljs"><span class="hljs-keyword">let</span> styles = \${
  stroke-<span class="hljs-attr">dasharray</span>: <span class="hljs-number">0.01</span> <span class="hljs-number">20</span>;
  stroke-<span class="hljs-attr">linecap</span>: round;
  stroke-<span class="hljs-attr">width</span>: <span class="hljs-number">8.4</span>;
};
</code></pre><h3>Merge Operator (<code>&lt;&lt;</code>)</h3>
<p>The <code>&lt;&lt;</code> operator merges two style blocks, with the right side overriding the left:</p>
<pre><code class="hljs"><span class="hljs-keyword">let</span> base = \${ <span class="hljs-attr">stroke</span>: red; stroke-<span class="hljs-attr">width</span>: <span class="hljs-number">2</span>; };
<span class="hljs-keyword">let</span> merged = base &lt;&lt; \${ stroke-<span class="hljs-attr">width</span>: <span class="hljs-number">4</span>; <span class="hljs-attr">fill</span>: blue; };
<span class="hljs-comment">// merged has: stroke: red, stroke-width: 4, fill: blue</span>
</code></pre><h3>Property Access</h3>
<p>Use dot notation with camelCase to read kebab-case properties:</p>
<pre><code class="hljs"><span class="hljs-keyword">let</span> styles = \${ stroke-<span class="hljs-attr">width</span>: <span class="hljs-number">4</span>; };
<span class="hljs-keyword">let</span> sw = styles.<span class="hljs-property">strokeWidth</span>;  <span class="hljs-comment">// reads &#x27;stroke-width&#x27; → &quot;4&quot;</span>
</code></pre><h3>Expression Evaluation in Values</h3>
<p>Style block values are try-evaluated: if a value parses and evaluates as an expression, its result is used. Otherwise the raw string is kept:</p>
<pre><code class="hljs"><span class="hljs-keyword">let</span> dynamic = \${
  font-<span class="hljs-attr">size</span>: <span class="hljs-title function_">calc</span>(<span class="hljs-number">12</span> + <span class="hljs-number">15</span>);       <span class="hljs-comment">// evaluates to &quot;27&quot;</span>
  stroke-<span class="hljs-attr">width</span>: <span class="hljs-title function_">randomRange</span>(<span class="hljs-number">2</span>, <span class="hljs-number">8</span>); <span class="hljs-comment">// evaluates to a random number</span>
  <span class="hljs-attr">stroke</span>: <span class="hljs-title function_">rgb</span>(<span class="hljs-number">232</span>, <span class="hljs-number">74</span>, <span class="hljs-number">166</span>);       <span class="hljs-comment">// kept as raw string</span>
  <span class="hljs-attr">fill</span>: #<span class="hljs-number">996633</span>;                   <span class="hljs-comment">// kept as raw string</span>
};
</code></pre><h3>Layer Definitions with Style Expressions</h3>
<p>Layer definitions accept any expression that evaluates to a style block:</p>
<pre><code class="hljs"><span class="hljs-keyword">let</span> baseStyles = \${ <span class="hljs-attr">stroke</span>: red; stroke-<span class="hljs-attr">width</span>: <span class="hljs-number">2</span>; };
define <span class="hljs-title class_">PathLayer</span>(<span class="hljs-string">&#x27;main&#x27;</span>) baseStyles &lt;&lt; \${ <span class="hljs-attr">fill</span>: none; }
</code></pre><h3>Per-Element Styles on Text and Tspan</h3>
<p>Pass style blocks as the 4th argument to <code>text()</code> or <code>tspan()</code>:</p>
<pre><code class="hljs"><span class="hljs-keyword">let</span> bold = \${ font-<span class="hljs-attr">weight</span>: bold; };
<span class="hljs-title function_">layer</span>(<span class="hljs-string">&#x27;labels&#x27;</span>).<span class="hljs-property">apply</span> {
  <span class="hljs-title function_">text</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">0</span>, bold)<span class="hljs-string">\`Hello\`</span>
  <span class="hljs-title function_">text</span>(<span class="hljs-params"><span class="hljs-number">50</span>, <span class="hljs-number">80</span></span>) {
    <span class="hljs-title function_">tspan</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, \${ <span class="hljs-attr">fill</span>: red; })<span class="hljs-string">\`colored\`</span>
  }
}
</code></pre><h2>Limitations</h2>
<ul>
<li><strong>No nesting</strong> — <code>layer().apply</code> blocks cannot be nested inside each other</li>
<li><strong>Layer order</strong> — layers render in definition order (first defined = bottom)</li>
</ul>
`;

export const debug = `<h1>Debug &amp; Console</h1>
<p>The playground includes debugging tools to help you understand how your code executes and inspect values during evaluation.</p>
<h2>Console Output</h2>
<p>Click the <strong>Console</strong> button in the header to view debug output.</p>
<h2>log() Function</h2>
<p>Use <code>log()</code> to inspect values during execution:</p>
<pre><code class="hljs"><span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;message&quot;</span>)           <span class="hljs-comment">// String message</span>
<span class="hljs-title function_">log</span>(myVar)               <span class="hljs-comment">// Variable with label</span>
<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;pos:&quot;</span>, ctx.<span class="hljs-property">position</span>) <span class="hljs-comment">// Multiple args</span>
<span class="hljs-title function_">log</span>(ctx)                 <span class="hljs-comment">// Full context object</span>
</code></pre><h3>Output Format</h3>
<p>String arguments display as-is. Other expressions show a label with the source:</p>
<pre><code class="hljs"><span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;radius is&quot;</span>, r)
<span class="hljs-comment">// Output:</span>
<span class="hljs-comment">// radius is</span>
<span class="hljs-comment">// r = 50</span>
</code></pre><p>Objects are expandable in the console - click the arrow to explore nested properties.</p>
<h2>ctx Object</h2>
<p>The <code>ctx</code> object tracks path state during evaluation:</p>
<h3>ctx.position</h3>
<p>Current pen position after the last command.</p>
<table>
<thead>
<tr>
<th>Property</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>ctx.position.x</code></td>
<td>X coordinate</td>
</tr>
<tr>
<td><code>ctx.position.y</code></td>
<td>Y coordinate</td>
</tr>
</tbody></table>
<pre><code class="hljs">M <span class="hljs-number">100</span> <span class="hljs-number">50</span>
<span class="hljs-title function_">log</span>(ctx.<span class="hljs-property">position</span>)  <span class="hljs-comment">// {x: 100, y: 50}</span>
L <span class="hljs-number">150</span> <span class="hljs-number">75</span>
<span class="hljs-title function_">log</span>(ctx.<span class="hljs-property">position</span>)  <span class="hljs-comment">// {x: 150, y: 75}</span>
</code></pre><h3>ctx.start</h3>
<p>Subpath start position (set by <code>M</code>/<code>m</code>, used by <code>Z</code>).</p>
<table>
<thead>
<tr>
<th>Property</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>ctx.start.x</code></td>
<td>X coordinate</td>
</tr>
<tr>
<td><code>ctx.start.y</code></td>
<td>Y coordinate</td>
</tr>
</tbody></table>
<h3>ctx.commands</h3>
<p>Array of all executed commands with their positions:</p>
<pre><code class="hljs"><span class="hljs-comment">// Each entry contains:</span>
{
  <span class="hljs-attr">command</span>: <span class="hljs-string">&quot;L&quot;</span>,        <span class="hljs-comment">// Command letter</span>
  <span class="hljs-attr">args</span>: [<span class="hljs-number">150</span>, <span class="hljs-number">75</span>],     <span class="hljs-comment">// Evaluated arguments</span>
  <span class="hljs-attr">start</span>: {<span class="hljs-attr">x</span>: <span class="hljs-number">100</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">50</span>},
  <span class="hljs-attr">end</span>: {<span class="hljs-attr">x</span>: <span class="hljs-number">150</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">75</span>}
}
</code></pre><h2>Using ctx in Paths</h2>
<p>Access position values with <code>calc()</code>:</p>
<pre><code class="hljs">M <span class="hljs-number">50</span> <span class="hljs-number">50</span>
<span class="hljs-comment">// Draw relative to current position</span>
L <span class="hljs-title function_">calc</span>(ctx.<span class="hljs-property">position</span>.<span class="hljs-property">x</span> + <span class="hljs-number">30</span>) ctx.<span class="hljs-property">position</span>.<span class="hljs-property">y</span>
<span class="hljs-title function_">circle</span>(ctx.<span class="hljs-property">position</span>.<span class="hljs-property">x</span>, ctx.<span class="hljs-property">position</span>.<span class="hljs-property">y</span>, <span class="hljs-number">5</span>)
</code></pre><h2>Example: Debug a Loop</h2>
<pre><code class="hljs">M <span class="hljs-number">20</span> <span class="hljs-number">100</span>
<span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">0.</span><span class="hljs-number">.4</span>) {
  <span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;iteration&quot;</span>, i, ctx.<span class="hljs-property">position</span>)
  L <span class="hljs-title function_">calc</span>(ctx.<span class="hljs-property">position</span>.<span class="hljs-property">x</span> + <span class="hljs-number">40</span>) <span class="hljs-number">100</span>
}
</code></pre><p>This logs the iteration number and current position at each step, helping you trace how the path is constructed.</p>
`;

export const cli = `<h1>CLI Reference</h1>
<p>The svg-path-extended CLI compiles extended SVG path syntax into standard SVG path strings or complete SVG files.</p>
<h2>Installation</h2>
<pre><code class="hljs language-bash">npm install -g svg-path-extended
</code></pre><p>Or use with npx:</p>
<pre><code class="hljs language-bash">npx svg-path-extended [options]
</code></pre><h2>Basic Usage</h2>
<h3>Compile a File</h3>
<pre><code class="hljs language-bash">svg-path-extended input.svgx
</code></pre><p>Or with the explicit flag:</p>
<pre><code class="hljs language-bash">svg-path-extended --src=input.svgx
</code></pre><h3>Compile Inline Code</h3>
<pre><code class="hljs language-bash">svg-path-extended -e <span class="hljs-string">&#x27;circle(100, 100, 50)&#x27;</span>
</code></pre><h3>Read from Stdin</h3>
<pre><code class="hljs language-bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;let x = 50; circle(x, x, 25)&#x27;</span> | svg-path-extended -
</code></pre><pre><code class="hljs language-bash"><span class="hljs-built_in">cat</span> myfile.svgx | svg-path-extended -
</code></pre><h2>Output Options</h2>
<h3>Output Path Data to File</h3>
<pre><code class="hljs language-bash">svg-path-extended --src=input.svgx -o output.txt
svg-path-extended --src=input.svgx --output output.txt
</code></pre><h3>Output as Complete SVG File</h3>
<p>Generate a complete SVG file with the path embedded:</p>
<pre><code class="hljs language-bash">svg-path-extended --src=input.svgx --output-svg-file=output.svg
</code></pre><p>This creates a ready-to-use SVG file that can be opened in any browser or image viewer.</p>
<h2>Annotated Output</h2>
<p>Use <code>--annotated</code> to get a human-readable debug output that shows:</p>
<ul>
<li>Original comments preserved in place</li>
<li>Loop iterations with line numbers</li>
<li>Function call annotations with expanded output</li>
<li>Each path command on its own line</li>
</ul>
<p>This is useful for debugging complex path generation or understanding how your code produces its output.</p>
<h3>Basic Usage</h3>
<pre><code class="hljs language-bash">svg-path-extended -e <span class="hljs-string">&#x27;for (i in 0..3) { M i 0 }&#x27;</span> --annotated
</code></pre><p>Output:</p>
<pre><code class="hljs"><span class="hljs-comment">//--- for (i in 0..3) from line 1</span>
  <span class="hljs-comment">//--- iteration 0</span>
  M <span class="hljs-number">0</span> <span class="hljs-number">0</span>
  <span class="hljs-comment">//--- iteration 1</span>
  M <span class="hljs-number">1</span> <span class="hljs-number">0</span>
  <span class="hljs-comment">//--- iteration 2</span>
  M <span class="hljs-number">2</span> <span class="hljs-number">0</span>
  <span class="hljs-comment">//--- iteration 3</span>
  M <span class="hljs-number">3</span> <span class="hljs-number">0</span>
</code></pre><h3>With Comments</h3>
<pre><code class="hljs language-bash">svg-path-extended -e <span class="hljs-string">&#x27;// Draw points
for (i in 0..3) { M i 0 }&#x27;</span> --annotated
</code></pre><p>Output:</p>
<pre><code class="hljs"><span class="hljs-comment">// Draw points</span>

<span class="hljs-comment">//--- for (i in 0..3) from line 2</span>
  <span class="hljs-comment">//--- iteration 0</span>
  M <span class="hljs-number">0</span> <span class="hljs-number">0</span>
  <span class="hljs-comment">//--- iteration 1</span>
  M <span class="hljs-number">1</span> <span class="hljs-number">0</span>
  <span class="hljs-comment">//--- iteration 2</span>
  M <span class="hljs-number">2</span> <span class="hljs-number">0</span>
  <span class="hljs-comment">//--- iteration 3</span>
  M <span class="hljs-number">3</span> <span class="hljs-number">0</span>
</code></pre><h3>Loop Truncation</h3>
<p>Long loops (&gt;10 iterations) are automatically truncated to show the first 3 and last 3 iterations:</p>
<pre><code class="hljs language-bash">svg-path-extended -e <span class="hljs-string">&#x27;for (i in 0..100) { M i 0 }&#x27;</span> --annotated
</code></pre><p>Output:</p>
<pre><code class="hljs"><span class="hljs-comment">//--- for (i in 0..100) from line 1</span>
  <span class="hljs-comment">//--- iteration 0</span>
  M <span class="hljs-number">0</span> <span class="hljs-number">0</span>
  <span class="hljs-comment">//--- iteration 1</span>
  M <span class="hljs-number">1</span> <span class="hljs-number">0</span>
  <span class="hljs-comment">//--- iteration 2</span>
  M <span class="hljs-number">2</span> <span class="hljs-number">0</span>
  ... <span class="hljs-number">95</span> more iterations ...
  <span class="hljs-comment">//--- iteration 98</span>
  M <span class="hljs-number">98</span> <span class="hljs-number">0</span>
  <span class="hljs-comment">//--- iteration 99</span>
  M <span class="hljs-number">99</span> <span class="hljs-number">0</span>
  <span class="hljs-comment">//--- iteration 100</span>
  M <span class="hljs-number">100</span> <span class="hljs-number">0</span>
</code></pre><h3>Function Call Annotations</h3>
<p>Function calls show their name, arguments, and expanded output:</p>
<pre><code class="hljs language-bash">svg-path-extended -e <span class="hljs-string">&#x27;circle(50, 50, 25)&#x27;</span> --annotated
</code></pre><p>Output:</p>
<pre><code class="hljs"><span class="hljs-comment">//--- circle(50, 50, 25) called from line 1</span>
  M <span class="hljs-number">25</span> <span class="hljs-number">50</span>
  A <span class="hljs-number">25</span> <span class="hljs-number">25</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">75</span> <span class="hljs-number">50</span>
  A <span class="hljs-number">25</span> <span class="hljs-number">25</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">25</span> <span class="hljs-number">50</span>
</code></pre><h3>Save to File</h3>
<pre><code class="hljs language-bash">svg-path-extended --src=complex.svgx --annotated -o debug-output.txt
</code></pre><h2>SVG Styling Options</h2>
<p>When using <code>--output-svg-file</code>, you can customize the appearance:</p>
<table>
<thead>
<tr>
<th>Option</th>
<th>Default</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>--stroke=&lt;color&gt;</code></td>
<td><code>#000</code></td>
<td>Stroke color</td>
</tr>
<tr>
<td><code>--fill=&lt;color&gt;</code></td>
<td><code>none</code></td>
<td>Fill color</td>
</tr>
<tr>
<td><code>--stroke-width=&lt;n&gt;</code></td>
<td><code>2</code></td>
<td>Stroke width</td>
</tr>
<tr>
<td><code>--viewBox=&lt;box&gt;</code></td>
<td><code>0 0 200 200</code></td>
<td>SVG viewBox</td>
</tr>
<tr>
<td><code>--width=&lt;w&gt;</code></td>
<td><code>200</code></td>
<td>SVG width</td>
</tr>
<tr>
<td><code>--height=&lt;h&gt;</code></td>
<td><code>200</code></td>
<td>SVG height</td>
</tr>
</tbody></table>
<h3>Examples</h3>
<p>Red circle with no fill:</p>
<pre><code class="hljs language-bash">svg-path-extended -e <span class="hljs-string">&#x27;circle(100, 100, 50)&#x27;</span> \\
  --output-svg-file=circle.svg \\
  --stroke=red \\
  --stroke-width=3
</code></pre><p>Blue filled polygon:</p>
<pre><code class="hljs language-bash">svg-path-extended -e <span class="hljs-string">&#x27;polygon(100, 100, 80, 6)&#x27;</span> \\
  --output-svg-file=hexagon.svg \\
  --stroke=navy \\
  --fill=lightblue \\
  --stroke-width=2
</code></pre><p>Large canvas with custom viewBox:</p>
<pre><code class="hljs language-bash">svg-path-extended --src=complex.svgx \\
  --output-svg-file=output.svg \\
  --viewBox=<span class="hljs-string">&quot;0 0 800 600&quot;</span> \\
  --width=800 \\
  --height=600
</code></pre><h2>Help and Version</h2>
<pre><code class="hljs language-bash">svg-path-extended --<span class="hljs-built_in">help</span>
svg-path-extended -h

svg-path-extended --version
svg-path-extended -v
</code></pre><h2>Exit Codes</h2>
<table>
<thead>
<tr>
<th>Code</th>
<th>Meaning</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>Success</td>
</tr>
<tr>
<td>1</td>
<td>Error (parse error, file not found, etc.)</td>
</tr>
</tbody></table>
<h2>File Extensions</h2>
<p>By convention, source files use the <code>.svgx</code> extension, but any text file will work.</p>
<h2>Examples</h2>
<h3>Generate a Spiral</h3>
<pre><code class="hljs language-bash">svg-path-extended -e <span class="hljs-string">&#x27;
M 100 100
for (i in 1..50) {
  L calc(100 + cos(i * 0.3) * i * 1.5) calc(100 + sin(i * 0.3) * i * 1.5)
}
&#x27;</span> --output-svg-file=spiral.svg --stroke=teal --stroke-width=2
</code></pre><h3>Process Multiple Files</h3>
<pre><code class="hljs language-bash"><span class="hljs-keyword">for</span> file <span class="hljs-keyword">in</span> examples/*.svgx; <span class="hljs-keyword">do</span>
  svg-path-extended --src=<span class="hljs-string">&quot;<span class="hljs-variable">$file</span>&quot;</span> --output-svg-file=<span class="hljs-string">&quot;<span class="hljs-variable">\${file%.svgx}</span>.svg&quot;</span>
<span class="hljs-keyword">done</span>
</code></pre><h3>Use in a Build Script</h3>
<pre><code class="hljs language-json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">&quot;build:icons&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;svg-path-extended --src=src/icons.svgx --output-svg-file=dist/icons.svg&quot;</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre>`;

export const examples = `<h1>Examples</h1>
<p>Practical examples showing how to use svg-path-extended for common tasks.</p>
<h2>Basic Shapes</h2>
<h3>Simple Rectangle</h3>
<pre><code class="hljs"><span class="hljs-title function_">rect</span>(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">180</span>, <span class="hljs-number">80</span>)
</code></pre><h3>Circle</h3>
<pre><code class="hljs"><span class="hljs-title function_">circle</span>(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">50</span>)
</code></pre><h3>Rounded Rectangle</h3>
<pre><code class="hljs">roundRect(20, 40, 160, 120, 15)
</code></pre><h2>Using Variables</h2>
<h3>Centered Circle</h3>
<pre><code class="hljs"><span class="hljs-keyword">let</span> width = <span class="hljs-number">200</span>;
<span class="hljs-keyword">let</span> height = <span class="hljs-number">200</span>;
<span class="hljs-keyword">let</span> cx = <span class="hljs-title function_">calc</span>(width / <span class="hljs-number">2</span>);
<span class="hljs-keyword">let</span> cy = <span class="hljs-title function_">calc</span>(height / <span class="hljs-number">2</span>);
<span class="hljs-keyword">let</span> r = <span class="hljs-number">40</span>;

<span class="hljs-title function_">circle</span>(cx, cy, r)
</code></pre><h3>Configurable Star</h3>
<pre><code class="hljs"><span class="hljs-keyword">let</span> centerX = <span class="hljs-number">100</span>;
<span class="hljs-keyword">let</span> centerY = <span class="hljs-number">100</span>;
<span class="hljs-keyword">let</span> outerR = <span class="hljs-number">60</span>;
<span class="hljs-keyword">let</span> innerR = <span class="hljs-number">25</span>;
<span class="hljs-keyword">let</span> points = <span class="hljs-number">5</span>;

<span class="hljs-title function_">star</span>(centerX, centerY, outerR, innerR, points)
</code></pre><h2>Loops and Patterns</h2>
<h3>Row of Circles</h3>
<pre><code class="hljs"><span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">0.</span><span class="hljs-number">.5</span>) {
  <span class="hljs-title function_">circle</span>(<span class="hljs-title function_">calc</span>(<span class="hljs-number">30</span> + i * <span class="hljs-number">35</span>), <span class="hljs-number">100</span>, <span class="hljs-number">15</span>)
}
</code></pre><h3>Grid of Dots</h3>
<pre><code class="hljs"><span class="hljs-keyword">for</span> (row <span class="hljs-keyword">in</span> <span class="hljs-number">0.</span><span class="hljs-number">.5</span>) {
  <span class="hljs-keyword">for</span> (col <span class="hljs-keyword">in</span> <span class="hljs-number">0.</span><span class="hljs-number">.5</span>) {
    <span class="hljs-title function_">circle</span>(<span class="hljs-title function_">calc</span>(<span class="hljs-number">20</span> + col * <span class="hljs-number">40</span>), <span class="hljs-title function_">calc</span>(<span class="hljs-number">20</span> + row * <span class="hljs-number">40</span>), <span class="hljs-number">5</span>)
  }
}
</code></pre><h3>Concentric Circles</h3>
<pre><code class="hljs"><span class="hljs-keyword">let</span> cx = <span class="hljs-number">100</span>;
<span class="hljs-keyword">let</span> cy = <span class="hljs-number">100</span>;

<span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">1.</span><span class="hljs-number">.6</span>) {
  <span class="hljs-title function_">circle</span>(cx, cy, <span class="hljs-title function_">calc</span>(i * <span class="hljs-number">15</span>))
}
</code></pre><h2>Trigonometry</h2>
<h3>Points on a Circle</h3>
<pre><code class="hljs"><span class="hljs-keyword">let</span> cx = <span class="hljs-number">100</span>;
<span class="hljs-keyword">let</span> cy = <span class="hljs-number">100</span>;
<span class="hljs-keyword">let</span> r = <span class="hljs-number">60</span>;
<span class="hljs-keyword">let</span> points = <span class="hljs-number">8</span>;

<span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">0.</span>.<span class="hljs-property">points</span>) {
  <span class="hljs-keyword">let</span> angle = <span class="hljs-title function_">calc</span>(i / points * <span class="hljs-title function_">TAU</span>());
  <span class="hljs-keyword">let</span> x = <span class="hljs-title function_">calc</span>(cx + <span class="hljs-title function_">cos</span>(angle) * r);
  <span class="hljs-keyword">let</span> y = <span class="hljs-title function_">calc</span>(cy + <span class="hljs-title function_">sin</span>(angle) * r);
  <span class="hljs-title function_">circle</span>(x, y, <span class="hljs-number">5</span>)
}
</code></pre><h3>Spiral</h3>
<pre><code class="hljs">M <span class="hljs-number">100</span> <span class="hljs-number">100</span>
<span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">1.</span><span class="hljs-number">.100</span>) {
  <span class="hljs-keyword">let</span> angle = <span class="hljs-title function_">calc</span>(i * <span class="hljs-number">0.2</span>);
  <span class="hljs-keyword">let</span> r = <span class="hljs-title function_">calc</span>(i * <span class="hljs-number">0.8</span>);
  L <span class="hljs-title function_">calc</span>(<span class="hljs-number">100</span> + <span class="hljs-title function_">cos</span>(angle) * r) <span class="hljs-title function_">calc</span>(<span class="hljs-number">100</span> + <span class="hljs-title function_">sin</span>(angle) * r)
}
</code></pre><h3>Sine Wave</h3>
<pre><code class="hljs">M <span class="hljs-number">0</span> <span class="hljs-number">100</span>
<span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">1.</span><span class="hljs-number">.40</span>) {
  <span class="hljs-keyword">let</span> x = <span class="hljs-title function_">calc</span>(i * <span class="hljs-number">5</span>);
  <span class="hljs-keyword">let</span> y = <span class="hljs-title function_">calc</span>(<span class="hljs-number">100</span> + <span class="hljs-title function_">sin</span>(i * <span class="hljs-number">0.3</span>) * <span class="hljs-number">30</span>);
  L x y
}
</code></pre><h3>Flower Pattern</h3>
<pre><code class="hljs"><span class="hljs-keyword">let</span> cx = <span class="hljs-number">100</span>;
<span class="hljs-keyword">let</span> cy = <span class="hljs-number">100</span>;
<span class="hljs-keyword">let</span> petalCount = <span class="hljs-number">6</span>;
<span class="hljs-keyword">let</span> petalRadius = <span class="hljs-number">25</span>;
<span class="hljs-keyword">let</span> centerRadius = <span class="hljs-number">15</span>;

<span class="hljs-comment">// Petals</span>
<span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">0.</span>.<span class="hljs-property">petalCount</span>) {
  <span class="hljs-keyword">let</span> angle = <span class="hljs-title function_">calc</span>(i / petalCount * <span class="hljs-title function_">TAU</span>());
  <span class="hljs-keyword">let</span> px = <span class="hljs-title function_">calc</span>(cx + <span class="hljs-title function_">cos</span>(angle) * <span class="hljs-number">35</span>);
  <span class="hljs-keyword">let</span> py = <span class="hljs-title function_">calc</span>(cy + <span class="hljs-title function_">sin</span>(angle) * <span class="hljs-number">35</span>);
  <span class="hljs-title function_">circle</span>(px, py, petalRadius)
}

<span class="hljs-comment">// Center</span>
<span class="hljs-title function_">circle</span>(cx, cy, centerRadius)
</code></pre><h2>Custom Functions</h2>
<h3>Reusable Square</h3>
<pre><code class="hljs">fn <span class="hljs-title function_">square</span>(<span class="hljs-params">x, y, size</span>) {
  <span class="hljs-title function_">rect</span>(x, y, size, size)
}

<span class="hljs-title function_">square</span>(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">50</span>)
<span class="hljs-title function_">square</span>(<span class="hljs-number">70</span>, <span class="hljs-number">10</span>, <span class="hljs-number">50</span>)
<span class="hljs-title function_">square</span>(<span class="hljs-number">130</span>, <span class="hljs-number">10</span>, <span class="hljs-number">50</span>)
</code></pre><h3>Diamond Shape</h3>
<pre><code class="hljs">fn <span class="hljs-title function_">diamond</span>(<span class="hljs-params">cx, cy, size</span>) {
  M cx <span class="hljs-title function_">calc</span>(cy - size)
  L <span class="hljs-title function_">calc</span>(cx + size) cy
  L cx <span class="hljs-title function_">calc</span>(cy + size)
  L <span class="hljs-title function_">calc</span>(cx - size) cy
  Z
}

<span class="hljs-title function_">diamond</span>(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">40</span>)
</code></pre><h3>Arrow</h3>
<pre><code class="hljs">fn <span class="hljs-title function_">arrow</span>(<span class="hljs-params">x1, y1, x2, y2, headSize</span>) {
  <span class="hljs-comment">// Line</span>
  M x1 y1
  L x2 y2

  <span class="hljs-comment">// Arrowhead (simplified)</span>
  <span class="hljs-keyword">let</span> angle = <span class="hljs-title function_">atan2</span>(<span class="hljs-title function_">calc</span>(y2 - y1), <span class="hljs-title function_">calc</span>(x2 - x1));
  <span class="hljs-keyword">let</span> a1 = <span class="hljs-title function_">calc</span>(angle + <span class="hljs-number">2.5</span>);
  <span class="hljs-keyword">let</span> a2 = <span class="hljs-title function_">calc</span>(angle - <span class="hljs-number">2.5</span>);

  M x2 y2
  L <span class="hljs-title function_">calc</span>(x2 - <span class="hljs-title function_">cos</span>(a1) * headSize) <span class="hljs-title function_">calc</span>(y2 - <span class="hljs-title function_">sin</span>(a1) * headSize)
  M x2 y2
  L <span class="hljs-title function_">calc</span>(x2 - <span class="hljs-title function_">cos</span>(a2) * headSize) <span class="hljs-title function_">calc</span>(y2 - <span class="hljs-title function_">sin</span>(a2) * headSize)
}

<span class="hljs-title function_">arrow</span>(<span class="hljs-number">20</span>, <span class="hljs-number">100</span>, <span class="hljs-number">180</span>, <span class="hljs-number">100</span>, <span class="hljs-number">15</span>)
</code></pre><h2>Conditionals</h2>
<h3>Size-Based Shape</h3>
<pre><code class="hljs"><span class="hljs-keyword">let</span> size = <span class="hljs-number">80</span>;

<span class="hljs-keyword">if</span> (size &gt; <span class="hljs-number">50</span>) {
  <span class="hljs-title function_">circle</span>(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>, size)
} <span class="hljs-keyword">else</span> {
  <span class="hljs-title function_">rect</span>(<span class="hljs-title function_">calc</span>(<span class="hljs-number">100</span> - size / <span class="hljs-number">2</span>), <span class="hljs-title function_">calc</span>(<span class="hljs-number">100</span> - size / <span class="hljs-number">2</span>), size, size)
}
</code></pre><h3>Alternating Pattern</h3>
<pre><code class="hljs"><span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">0.</span><span class="hljs-number">.10</span>) {
  <span class="hljs-keyword">let</span> x = <span class="hljs-title function_">calc</span>(<span class="hljs-number">20</span> + i * <span class="hljs-number">18</span>);
  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">calc</span>(i % <span class="hljs-number">2</span>) == <span class="hljs-number">0</span>) {
    <span class="hljs-title function_">circle</span>(x, <span class="hljs-number">100</span>, <span class="hljs-number">8</span>)
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-title function_">rect</span>(<span class="hljs-title function_">calc</span>(x - <span class="hljs-number">6</span>), <span class="hljs-number">94</span>, <span class="hljs-number">12</span>, <span class="hljs-number">12</span>)
  }
}
</code></pre><h2>Complex Examples</h2>
<h3>Gear Shape</h3>
<pre><code class="hljs"><span class="hljs-keyword">let</span> cx = <span class="hljs-number">100</span>;
<span class="hljs-keyword">let</span> cy = <span class="hljs-number">100</span>;
<span class="hljs-keyword">let</span> innerR = <span class="hljs-number">30</span>;
<span class="hljs-keyword">let</span> outerR = <span class="hljs-number">50</span>;
<span class="hljs-keyword">let</span> teeth = <span class="hljs-number">12</span>;

M <span class="hljs-title function_">calc</span>(cx + outerR) cy

<span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">0.</span>.<span class="hljs-property">teeth</span>) {
  <span class="hljs-keyword">let</span> a1 = <span class="hljs-title function_">calc</span>(i / teeth * <span class="hljs-title function_">TAU</span>());
  <span class="hljs-keyword">let</span> a2 = <span class="hljs-title function_">calc</span>((i + <span class="hljs-number">0.3</span>) / teeth * <span class="hljs-title function_">TAU</span>());
  <span class="hljs-keyword">let</span> a3 = <span class="hljs-title function_">calc</span>((i + <span class="hljs-number">0.5</span>) / teeth * <span class="hljs-title function_">TAU</span>());
  <span class="hljs-keyword">let</span> a4 = <span class="hljs-title function_">calc</span>((i + <span class="hljs-number">0.8</span>) / teeth * <span class="hljs-title function_">TAU</span>());

  L <span class="hljs-title function_">calc</span>(cx + <span class="hljs-title function_">cos</span>(a1) * outerR) <span class="hljs-title function_">calc</span>(cy + <span class="hljs-title function_">sin</span>(a1) * outerR)
  L <span class="hljs-title function_">calc</span>(cx + <span class="hljs-title function_">cos</span>(a2) * outerR) <span class="hljs-title function_">calc</span>(cy + <span class="hljs-title function_">sin</span>(a2) * outerR)
  L <span class="hljs-title function_">calc</span>(cx + <span class="hljs-title function_">cos</span>(a3) * innerR) <span class="hljs-title function_">calc</span>(cy + <span class="hljs-title function_">sin</span>(a3) * innerR)
  L <span class="hljs-title function_">calc</span>(cx + <span class="hljs-title function_">cos</span>(a4) * innerR) <span class="hljs-title function_">calc</span>(cy + <span class="hljs-title function_">sin</span>(a4) * innerR)
}

Z

<span class="hljs-comment">// Center hole</span>
<span class="hljs-title function_">circle</span>(cx, cy, <span class="hljs-number">10</span>)
</code></pre><h3>Recursive-Style Tree (using loops)</h3>
<pre><code class="hljs"><span class="hljs-comment">// Simple branching pattern</span>
fn <span class="hljs-title function_">branch</span>(<span class="hljs-params">x, y, length, angle, depth</span>) {
  <span class="hljs-keyword">let</span> x2 = <span class="hljs-title function_">calc</span>(x + <span class="hljs-title function_">cos</span>(angle) * length);
  <span class="hljs-keyword">let</span> y2 = <span class="hljs-title function_">calc</span>(y + <span class="hljs-title function_">sin</span>(angle) * length);
  M x y
  L x2 y2
}

<span class="hljs-keyword">let</span> startX = <span class="hljs-number">100</span>;
<span class="hljs-keyword">let</span> startY = <span class="hljs-number">180</span>;

<span class="hljs-comment">// Trunk</span>
M startX startY
L startX <span class="hljs-number">120</span>

<span class="hljs-comment">// Main branches</span>
<span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">0.</span><span class="hljs-number">.5</span>) {
  <span class="hljs-keyword">let</span> angle = <span class="hljs-title function_">calc</span>(-<span class="hljs-number">1.57</span> + (i - <span class="hljs-number">2</span>) * <span class="hljs-number">0.4</span>);
  <span class="hljs-keyword">let</span> len = <span class="hljs-title function_">calc</span>(<span class="hljs-number">30</span> - <span class="hljs-title function_">abs</span>(i - <span class="hljs-number">2</span>) * <span class="hljs-number">5</span>);
  <span class="hljs-title function_">branch</span>(startX, <span class="hljs-number">120</span>, len, angle, <span class="hljs-number">0</span>)
}
</code></pre><h2>Tips</h2>
<ol>
<li><strong>Start simple</strong>: Build complex shapes from simple parts</li>
<li><strong>Use variables</strong>: Makes code readable and adjustable</li>
<li><strong>Extract functions</strong>: Reuse common patterns</li>
<li><strong>Test incrementally</strong>: Generate SVGs often to see results</li>
<li><strong>Use comments</strong>: Document your intent for complex sections</li>
</ol>
`;

// All available documentation sections
export const sections = {
  gettingStarted,
  syntax,
  stdlib,
  layers,
  debug,
  cli,
  examples,
};

// Syntax highlighting themes (GitHub light/dark)
export const hljsThemeLight = `pre code.hljs {
  display: block;
  overflow-x: auto;
  padding: 1em
}
code.hljs {
  padding: 3px 5px
}
/*!
  Theme: GitHub
  Description: Light theme as seen on github.com
  Author: github.com
  Maintainer: @Hirse
  Updated: 2021-05-15

  Outdated base version: https://github.com/primer/github-syntax-light
  Current colors taken from GitHub's CSS
*/
.hljs {
  color: #24292e;
  background: #ffffff
}
.hljs-doctag,
.hljs-keyword,
.hljs-meta .hljs-keyword,
.hljs-template-tag,
.hljs-template-variable,
.hljs-type,
.hljs-variable.language_ {
  /* prettylights-syntax-keyword */
  color: #d73a49
}
.hljs-title,
.hljs-title.class_,
.hljs-title.class_.inherited__,
.hljs-title.function_ {
  /* prettylights-syntax-entity */
  color: #6f42c1
}
.hljs-attr,
.hljs-attribute,
.hljs-literal,
.hljs-meta,
.hljs-number,
.hljs-operator,
.hljs-variable,
.hljs-selector-attr,
.hljs-selector-class,
.hljs-selector-id {
  /* prettylights-syntax-constant */
  color: #005cc5
}
.hljs-regexp,
.hljs-string,
.hljs-meta .hljs-string {
  /* prettylights-syntax-string */
  color: #032f62
}
.hljs-built_in,
.hljs-symbol {
  /* prettylights-syntax-variable */
  color: #e36209
}
.hljs-comment,
.hljs-code,
.hljs-formula {
  /* prettylights-syntax-comment */
  color: #6a737d
}
.hljs-name,
.hljs-quote,
.hljs-selector-tag,
.hljs-selector-pseudo {
  /* prettylights-syntax-entity-tag */
  color: #22863a
}
.hljs-subst {
  /* prettylights-syntax-storage-modifier-import */
  color: #24292e
}
.hljs-section {
  /* prettylights-syntax-markup-heading */
  color: #005cc5;
  font-weight: bold
}
.hljs-bullet {
  /* prettylights-syntax-markup-list */
  color: #735c0f
}
.hljs-emphasis {
  /* prettylights-syntax-markup-italic */
  color: #24292e;
  font-style: italic
}
.hljs-strong {
  /* prettylights-syntax-markup-bold */
  color: #24292e;
  font-weight: bold
}
.hljs-addition {
  /* prettylights-syntax-markup-inserted */
  color: #22863a;
  background-color: #f0fff4
}
.hljs-deletion {
  /* prettylights-syntax-markup-deleted */
  color: #b31d28;
  background-color: #ffeef0
}
.hljs-char.escape_,
.hljs-link,
.hljs-params,
.hljs-property,
.hljs-punctuation,
.hljs-tag {
  /* purposely ignored */
  
}`;

export const hljsThemeDark = `pre code.hljs {
  display: block;
  overflow-x: auto;
  padding: 1em
}
code.hljs {
  padding: 3px 5px
}
/*!
  Theme: GitHub Dark
  Description: Dark theme as seen on github.com
  Author: github.com
  Maintainer: @Hirse
  Updated: 2021-05-15

  Outdated base version: https://github.com/primer/github-syntax-dark
  Current colors taken from GitHub's CSS
*/
.hljs {
  color: #c9d1d9;
  background: #0d1117
}
.hljs-doctag,
.hljs-keyword,
.hljs-meta .hljs-keyword,
.hljs-template-tag,
.hljs-template-variable,
.hljs-type,
.hljs-variable.language_ {
  /* prettylights-syntax-keyword */
  color: #ff7b72
}
.hljs-title,
.hljs-title.class_,
.hljs-title.class_.inherited__,
.hljs-title.function_ {
  /* prettylights-syntax-entity */
  color: #d2a8ff
}
.hljs-attr,
.hljs-attribute,
.hljs-literal,
.hljs-meta,
.hljs-number,
.hljs-operator,
.hljs-variable,
.hljs-selector-attr,
.hljs-selector-class,
.hljs-selector-id {
  /* prettylights-syntax-constant */
  color: #79c0ff
}
.hljs-regexp,
.hljs-string,
.hljs-meta .hljs-string {
  /* prettylights-syntax-string */
  color: #a5d6ff
}
.hljs-built_in,
.hljs-symbol {
  /* prettylights-syntax-variable */
  color: #ffa657
}
.hljs-comment,
.hljs-code,
.hljs-formula {
  /* prettylights-syntax-comment */
  color: #8b949e
}
.hljs-name,
.hljs-quote,
.hljs-selector-tag,
.hljs-selector-pseudo {
  /* prettylights-syntax-entity-tag */
  color: #7ee787
}
.hljs-subst {
  /* prettylights-syntax-storage-modifier-import */
  color: #c9d1d9
}
.hljs-section {
  /* prettylights-syntax-markup-heading */
  color: #1f6feb;
  font-weight: bold
}
.hljs-bullet {
  /* prettylights-syntax-markup-list */
  color: #f2cc60
}
.hljs-emphasis {
  /* prettylights-syntax-markup-italic */
  color: #c9d1d9;
  font-style: italic
}
.hljs-strong {
  /* prettylights-syntax-markup-bold */
  color: #c9d1d9;
  font-weight: bold
}
.hljs-addition {
  /* prettylights-syntax-markup-inserted */
  color: #aff5b4;
  background-color: #033a16
}
.hljs-deletion {
  /* prettylights-syntax-markup-deleted */
  color: #ffdcd7;
  background-color: #67060c
}
.hljs-char.escape_,
.hljs-link,
.hljs-params,
.hljs-property,
.hljs-punctuation,
.hljs-tag {
  /* purposely ignored */
  
}`;
