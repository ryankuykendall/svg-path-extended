// Auto-generated by scripts/build-docs.js
// Do not edit manually - edit the markdown files in /docs/ instead

export const gettingStarted = `<h1>Getting Started</h1>
<p>svg-path-extended is a language that extends SVG path syntax with variables, expressions, control flow, and functions. It compiles to standard SVG path data that works in any browser or graphics application.</p>
<h2>Your First Path</h2>
<p>Try this simple example in the playground:</p>
<pre><code>// A simple rectangle using variables
let size = 50
let x = 10
let y = 10

M x y
h size
v size
h calc(-size)
Z
</code></pre>
<p>This creates a rectangle by:</p>
<ol>
<li>Moving to position (10, 10)</li>
<li>Drawing a horizontal line of length 50</li>
<li>Drawing a vertical line of length 50</li>
<li>Drawing a horizontal line back</li>
<li>Closing the path</li>
</ol>
<h2>Why svg-path-extended?</h2>
<p>SVG paths are powerful but writing them by hand is tedious:</p>
<pre><code>// Standard SVG - repetitive coordinates
M 20 20 L 80 20 L 80 80 L 20 80 Z
M 100 20 L 160 20 L 160 80 L 100 80 Z
M 180 20 L 240 20 L 240 80 L 180 80 Z
</code></pre>
<p>With svg-path-extended, you can use variables and loops:</p>
<pre><code>// svg-path-extended - DRY and readable
let size = 60
for (i in 0..3) {
  rect(calc(20 + i * 80), 20, size, size)
}
</code></pre>
<h2>Key Features</h2>
<h3>Variables</h3>
<p>Store and reuse values:</p>
<pre><code>let width = 200
let height = 100
let centerX = calc(width / 2)
</code></pre>
<h3>Expressions with calc()</h3>
<p>Use math in path commands:</p>
<pre><code>let r = 50
M calc(100 - r) 100
L calc(100 + r) 100
</code></pre>
<h3>Loops</h3>
<p>Repeat patterns easily:</p>
<pre><code>for (i in 0..10) {
  circle(calc(20 + i * 30), 100, 10)
}
</code></pre>
<h3>Functions</h3>
<p>Define reusable shapes:</p>
<pre><code>fn square(x, y, size) {
  rect(x, y, size, size)
}

square(10, 10, 50)
square(70, 10, 50)
</code></pre>
<h3>Built-in Shapes</h3>
<p>Common shapes are included:</p>
<pre><code>circle(100, 100, 50)
rect(10, 10, 80, 60)
polygon(100, 100, 40, 6)  // hexagon
star(100, 100, 50, 25, 5)
</code></pre>
<h2>Next Steps</h2>
<ul>
<li><strong>Syntax Reference</strong> - Learn all the language features</li>
<li><strong>Standard Library</strong> - Explore built-in functions</li>
<li><strong>Examples</strong> - See practical patterns and recipes</li>
</ul>
`;

export const syntax = `<h1>Syntax Reference</h1>
<p>svg-path-extended is a superset of SVG path syntax that adds variables, expressions, control flow, and functions.</p>
<h2>Path Commands</h2>
<p>All standard SVG path commands are supported:</p>
<table>
<thead>
<tr>
<th>Command</th>
<th>Name</th>
<th>Parameters</th>
</tr>
</thead>
<tbody><tr>
<td><code>M</code> / <code>m</code></td>
<td>Move to</td>
<td><code>x y</code></td>
</tr>
<tr>
<td><code>L</code> / <code>l</code></td>
<td>Line to</td>
<td><code>x y</code></td>
</tr>
<tr>
<td><code>H</code> / <code>h</code></td>
<td>Horizontal line</td>
<td><code>x</code></td>
</tr>
<tr>
<td><code>V</code> / <code>v</code></td>
<td>Vertical line</td>
<td><code>y</code></td>
</tr>
<tr>
<td><code>C</code> / <code>c</code></td>
<td>Cubic bezier</td>
<td><code>x1 y1 x2 y2 x y</code></td>
</tr>
<tr>
<td><code>S</code> / <code>s</code></td>
<td>Smooth cubic</td>
<td><code>x2 y2 x y</code></td>
</tr>
<tr>
<td><code>Q</code> / <code>q</code></td>
<td>Quadratic bezier</td>
<td><code>x1 y1 x y</code></td>
</tr>
<tr>
<td><code>T</code> / <code>t</code></td>
<td>Smooth quadratic</td>
<td><code>x y</code></td>
</tr>
<tr>
<td><code>A</code> / <code>a</code></td>
<td>Arc</td>
<td><code>rx ry rotation large-arc sweep x y</code></td>
</tr>
<tr>
<td><code>Z</code> / <code>z</code></td>
<td>Close path</td>
<td>(none)</td>
</tr>
</tbody></table>
<p>Uppercase commands use absolute coordinates; lowercase use relative coordinates.</p>
<pre><code>M 0 0 L 100 100 Z
</code></pre>
<h2>Variables</h2>
<p>Declare variables with <code>let</code>:</p>
<pre><code>let width = 200;
let height = 100;
let centerX = 100;
</code></pre>
<p>Use variables directly in path commands:</p>
<pre><code>let x = 50;
let y = 75;
M x y L 100 100
</code></pre>
<p><strong>Note</strong>: Single letters that are path commands (M, L, C, etc.) cannot be used as variable names.</p>
<h2>Expressions with calc()</h2>
<p>For mathematical expressions, wrap them in <code>calc()</code>:</p>
<pre><code>let r = 50;
M calc(100 - r) 100
L calc(100 + r) 100
</code></pre>
<h3>Supported Operators</h3>
<table>
<thead>
<tr>
<th>Operator</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>+</code></td>
<td>Addition</td>
</tr>
<tr>
<td><code>-</code></td>
<td>Subtraction</td>
</tr>
<tr>
<td><code>*</code></td>
<td>Multiplication</td>
</tr>
<tr>
<td><code>/</code></td>
<td>Division</td>
</tr>
<tr>
<td><code>%</code></td>
<td>Modulo</td>
</tr>
<tr>
<td><code>&lt;</code></td>
<td>Less than</td>
</tr>
<tr>
<td><code>&gt;</code></td>
<td>Greater than</td>
</tr>
<tr>
<td><code>&lt;=</code></td>
<td>Less than or equal</td>
</tr>
<tr>
<td><code>&gt;=</code></td>
<td>Greater than or equal</td>
</tr>
<tr>
<td><code>==</code></td>
<td>Equal</td>
</tr>
<tr>
<td><code>!=</code></td>
<td>Not equal</td>
</tr>
<tr>
<td><code>&amp;&amp;</code></td>
<td>Logical AND</td>
</tr>
<tr>
<td><code>||</code></td>
<td>Logical OR</td>
</tr>
<tr>
<td><code>!</code></td>
<td>Logical NOT (unary)</td>
</tr>
<tr>
<td><code>-</code></td>
<td>Negation (unary)</td>
</tr>
</tbody></table>
<p>Operator precedence follows standard mathematical conventions.</p>
<h2>Angle Units</h2>
<p>Numbers can have angle unit suffixes for convenience:</p>
<table>
<thead>
<tr>
<th>Suffix</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>45deg</code></td>
<td>Degrees (converted to radians internally)</td>
</tr>
<tr>
<td><code>1.5rad</code></td>
<td>Radians (no conversion)</td>
</tr>
</tbody></table>
<pre><code>let angle = 90deg;
M sin(45deg) cos(45deg)

// Equivalent to:
let angle = rad(90);
M sin(rad(45)) cos(rad(45))
</code></pre>
<p>This is especially useful with trigonometric functions and polar coordinates.</p>
<h2>For Loops</h2>
<p>Repeat path commands with <code>for</code>:</p>
<pre><code>for (i in 0..10) {
  L calc(i * 20) calc(i * 10)
}
</code></pre>
<p>The range <code>0..10</code> includes both endpoints (0 through 10, giving 11 iterations).</p>
<h3>Descending Ranges</h3>
<p>Ranges automatically count down when start &gt; end:</p>
<pre><code>// Countdown from 5 to 1
for (i in 5..1) {
  M calc(i * 20) 0
}
// Produces: M 100 0 M 80 0 M 60 0 M 40 0 M 20 0
</code></pre>
<h3>Nested Loops</h3>
<pre><code>for (row in 0..2) {
  for (col in 0..2) {
    circle(calc(col * 50 + 25), calc(row * 50 + 25), 10)
  }
}
</code></pre>
<p>This creates a 3x3 grid (rows 0, 1, 2 and cols 0, 1, 2).</p>
<h2>Conditionals</h2>
<p>Use <code>if</code> and <code>else</code> for conditional path generation:</p>
<pre><code>let size = 100;

if (size &gt; 50) {
  M 0 0 L 100 100
} else {
  M 0 0 L 50 50
}
</code></pre>
<p>Comparison results are numeric: <code>1</code> for true, <code>0</code> for false.</p>
<h2>Functions</h2>
<h3>Defining Functions</h3>
<p>Create reusable path generators with <code>fn</code>:</p>
<pre><code>fn square(x, y, size) {
  rect(x, y, size, size)
}
</code></pre>
<h3>Calling Functions</h3>
<pre><code>square(10, 10, 50)
square(70, 10, 50)
</code></pre>
<p>Functions can call other functions and use all language features.</p>
<h2>Comments</h2>
<p>Line comments start with <code>//</code>:</p>
<pre><code>// This is a comment
let x = 50;  // inline comment
M x 0
</code></pre>
<h2>Path Context (ctx)</h2>
<p>When using <code>compileWithContext()</code>, a <code>ctx</code> object tracks the current drawing state:</p>
<pre><code>M 10 20
L 30 40
L calc(ctx.position.x + 10) ctx.position.y  // L 40 40
</code></pre>
<h3>ctx Properties</h3>
<table>
<thead>
<tr>
<th>Property</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>ctx.position.x</code></td>
<td>number</td>
<td>Current X coordinate</td>
</tr>
<tr>
<td><code>ctx.position.y</code></td>
<td>number</td>
<td>Current Y coordinate</td>
</tr>
<tr>
<td><code>ctx.start.x</code></td>
<td>number</td>
<td>Subpath start X (set by M, used by Z)</td>
</tr>
<tr>
<td><code>ctx.start.y</code></td>
<td>number</td>
<td>Subpath start Y</td>
</tr>
<tr>
<td><code>ctx.commands</code></td>
<td>array</td>
<td>History of executed commands</td>
</tr>
</tbody></table>
<h3>How Position Updates</h3>
<ul>
<li><strong>M/m</strong>: Sets position and subpath start</li>
<li><strong>L/l, H/h, V/v</strong>: Updates position to endpoint</li>
<li><strong>C/c, S/s, Q/q, T/t</strong>: Updates position to curve endpoint</li>
<li><strong>A/a</strong>: Updates position to arc endpoint</li>
<li><strong>Z/z</strong>: Returns to subpath start</li>
</ul>
<p>Lowercase (relative) commands add to current position; uppercase (absolute) set it directly.</p>
<h3>log() Function</h3>
<p>Use <code>log()</code> to inspect the context during evaluation:</p>
<pre><code>M 10 20
log(ctx)           // Logs full context as JSON
log(ctx.position)  // Logs just position object
log(ctx.position.x) // Logs just the x value
L 30 40
</code></pre>
<p>The logs are captured in the <code>logs</code> array returned by <code>compileWithContext()</code>.</p>
<h3>Example: Drawing Relative to Current Position</h3>
<pre><code>M 100 100
L 150 150
// Continue from current position
L calc(ctx.position.x + 50) ctx.position.y
L ctx.position.x calc(ctx.position.y + 50)
Z
</code></pre>
<h2>Complete Example</h2>
<pre><code>// Draw a grid of circles with varying sizes
let cols = 5;
let rows = 5;
let spacing = 40;

for (row in 0..rows) {
  for (col in 0..cols) {
    let x = calc(col * spacing + 20);
    let y = calc(row * spacing + 20);
    let r = calc(5 + col + row);
    circle(x, y, r)
  }
}
</code></pre>
`;

export const stdlib = `<h1>Standard Library Reference</h1>
<p>svg-path-extended includes built-in functions for math operations and common SVG shapes.</p>
<h2>Math Functions</h2>
<h3>Trigonometry</h3>
<p>All trigonometric functions use radians.</p>
<table>
<thead>
<tr>
<th>Function</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>sin(x)</code></td>
<td>Sine</td>
</tr>
<tr>
<td><code>cos(x)</code></td>
<td>Cosine</td>
</tr>
<tr>
<td><code>tan(x)</code></td>
<td>Tangent</td>
</tr>
<tr>
<td><code>asin(x)</code></td>
<td>Arc sine</td>
</tr>
<tr>
<td><code>acos(x)</code></td>
<td>Arc cosine</td>
</tr>
<tr>
<td><code>atan(x)</code></td>
<td>Arc tangent</td>
</tr>
<tr>
<td><code>atan2(y, x)</code></td>
<td>Two-argument arc tangent</td>
</tr>
</tbody></table>
<pre><code>// Draw a point on a circle
let angle = 0.5;
let r = 50;
M calc(100 + cos(angle) * r) calc(100 + sin(angle) * r)
</code></pre>
<h3>Angle Conversion</h3>
<table>
<thead>
<tr>
<th>Function</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>rad(degrees)</code></td>
<td>Convert degrees to radians</td>
</tr>
<tr>
<td><code>deg(radians)</code></td>
<td>Convert radians to degrees</td>
</tr>
</tbody></table>
<pre><code>// Use degrees instead of radians
let angle = rad(45);
M calc(cos(angle) * 50) calc(sin(angle) * 50)
</code></pre>
<h3>Exponential &amp; Logarithmic</h3>
<table>
<thead>
<tr>
<th>Function</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>exp(x)</code></td>
<td>e raised to power x</td>
</tr>
<tr>
<td><code>log(x)</code></td>
<td>Natural logarithm</td>
</tr>
<tr>
<td><code>log10(x)</code></td>
<td>Base-10 logarithm</td>
</tr>
<tr>
<td><code>log2(x)</code></td>
<td>Base-2 logarithm</td>
</tr>
<tr>
<td><code>pow(x, y)</code></td>
<td>x raised to power y</td>
</tr>
<tr>
<td><code>sqrt(x)</code></td>
<td>Square root</td>
</tr>
<tr>
<td><code>cbrt(x)</code></td>
<td>Cube root</td>
</tr>
</tbody></table>
<h3>Rounding</h3>
<table>
<thead>
<tr>
<th>Function</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>floor(x)</code></td>
<td>Round down</td>
</tr>
<tr>
<td><code>ceil(x)</code></td>
<td>Round up</td>
</tr>
<tr>
<td><code>round(x)</code></td>
<td>Round to nearest integer</td>
</tr>
<tr>
<td><code>trunc(x)</code></td>
<td>Truncate decimal part</td>
</tr>
</tbody></table>
<h3>Utility</h3>
<table>
<thead>
<tr>
<th>Function</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>abs(x)</code></td>
<td>Absolute value</td>
</tr>
<tr>
<td><code>sign(x)</code></td>
<td>Sign (-1, 0, or 1)</td>
</tr>
<tr>
<td><code>min(a, b, ...)</code></td>
<td>Minimum value</td>
</tr>
<tr>
<td><code>max(a, b, ...)</code></td>
<td>Maximum value</td>
</tr>
</tbody></table>
<h3>Interpolation &amp; Clamping</h3>
<table>
<thead>
<tr>
<th>Function</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>lerp(a, b, t)</code></td>
<td>Linear interpolation: <code>a + (b - a) * t</code></td>
</tr>
<tr>
<td><code>clamp(value, min, max)</code></td>
<td>Constrain value to range</td>
</tr>
<tr>
<td><code>map(value, inMin, inMax, outMin, outMax)</code></td>
<td>Map value from one range to another</td>
</tr>
</tbody></table>
<pre><code>// Interpolate between two positions
let t = 0.5;
M calc(lerp(0, 100, t)) calc(lerp(0, 50, t))

// Clamp a value
let x = clamp(150, 0, 100);  // Result: 100
</code></pre>
<h3>Constants</h3>
<table>
<thead>
<tr>
<th>Function</th>
<th>Returns</th>
</tr>
</thead>
<tbody><tr>
<td><code>PI()</code></td>
<td>3.14159...</td>
</tr>
<tr>
<td><code>E()</code></td>
<td>2.71828...</td>
</tr>
<tr>
<td><code>TAU()</code></td>
<td>6.28318... (2π)</td>
</tr>
</tbody></table>
<pre><code>// Draw a semicircle
let r = 50;
for (i in 0..20) {
  let angle = calc(i / 20 * PI());
  L calc(100 + cos(angle) * r) calc(100 + sin(angle) * r)
}
</code></pre>
<h3>Random</h3>
<table>
<thead>
<tr>
<th>Function</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>random()</code></td>
<td>Random number between 0 and 1</td>
</tr>
<tr>
<td><code>randomRange(min, max)</code></td>
<td>Random number in range</td>
</tr>
</tbody></table>
<p><strong>Note</strong>: Random functions are not deterministic. Each call produces a different value.</p>
<hr>
<h2>Path Functions</h2>
<p>These functions generate complete path segments.</p>
<h3>circle(cx, cy, r)</h3>
<p>Draws a circle centered at (cx, cy) with radius r.</p>
<pre><code>circle(100, 100, 50)
</code></pre>
<p>Output: A full circle using two arc commands.</p>
<h3>rect(x, y, width, height)</h3>
<p>Draws a rectangle.</p>
<pre><code>rect(10, 10, 80, 60)
</code></pre>
<h3>roundRect(x, y, width, height, radius)</h3>
<p>Draws a rectangle with rounded corners.</p>
<pre><code>roundRect(10, 10, 80, 60, 10)
</code></pre>
<h3>polygon(cx, cy, radius, sides)</h3>
<p>Draws a regular polygon.</p>
<pre><code>polygon(100, 100, 50, 6)  // Hexagon
polygon(100, 100, 50, 8)  // Octagon
</code></pre>
<h3>star(cx, cy, outerRadius, innerRadius, points)</h3>
<p>Draws a star shape.</p>
<pre><code>star(100, 100, 50, 25, 5)  // 5-pointed star
</code></pre>
<h3>line(x1, y1, x2, y2)</h3>
<p>Draws a line segment.</p>
<pre><code>line(0, 0, 100, 100)
</code></pre>
<h3>arc(rx, ry, rotation, largeArc, sweep, x, y)</h3>
<p>Draws an arc to (x, y). This is a direct wrapper around the SVG <code>A</code> command.</p>
<pre><code>M 50 100
arc(50, 50, 0, 1, 1, 150, 100)
</code></pre>
<h3>quadratic(x1, y1, cx, cy, x2, y2)</h3>
<p>Draws a quadratic bezier curve from (x1, y1) to (x2, y2) with control point (cx, cy).</p>
<pre><code>quadratic(0, 100, 50, 0, 100, 100)
</code></pre>
<h3>cubic(x1, y1, c1x, c1y, c2x, c2y, x2, y2)</h3>
<p>Draws a cubic bezier curve.</p>
<pre><code>cubic(0, 100, 25, 0, 75, 0, 100, 100)
</code></pre>
<h3>moveTo(x, y)</h3>
<p>Returns a move command. Useful inside functions.</p>
<pre><code>moveTo(50, 50)
</code></pre>
<h3>lineTo(x, y)</h3>
<p>Returns a line command.</p>
<pre><code>lineTo(100, 100)
</code></pre>
<h3>closePath()</h3>
<p>Returns a close path command.</p>
<pre><code>closePath()
</code></pre>
<hr>
<h2>Context-Aware Functions</h2>
<p>These functions use the current path context (position, tangent direction) to generate path segments. They maintain path continuity and are ideal for building complex shapes programmatically.</p>
<h3>Polar Movement</h3>
<h4>polarPoint(angle, distance)</h4>
<p>Returns a point at a polar offset from current position. Does not emit any path commands.</p>
<pre><code>M 100 100
let p = polarPoint(0, 50);
L p.x p.y  // Line to (150, 100)
</code></pre>
<h4>polarOffset(angle, distance)</h4>
<p>Returns <code>{x, y}</code> coordinates at a polar offset. Similar to <code>polarPoint</code>.</p>
<h4>polarMove(angle, distance)</h4>
<p>Emits a line command (<code>L</code>) moving in the specified direction. Updates position but draws a visible line.</p>
<pre><code>M 100 100
polarMove(0, 50)  // Draws line to (150, 100)
</code></pre>
<h4>polarLine(angle, distance)</h4>
<p>Emits a line command (<code>L</code>) in the specified direction. Same as <code>polarMove</code>.</p>
<pre><code>M 100 100
polarLine(45deg, 70.7)  // Draws line diagonally
</code></pre>
<h3>Arc Functions</h3>
<h4>arcFromCenter(dcx, dcy, radius, startAngle, endAngle, clockwise)</h4>
<p>Draws an arc defined by center offset and angles. Returns <code>{point, angle}</code> with endpoint and tangent.</p>
<ul>
<li><code>dcx, dcy</code>: Offset from current position to arc center</li>
<li><code>radius</code>: Arc radius</li>
<li><code>startAngle, endAngle</code>: Start and end angles in radians</li>
<li><code>clockwise</code>: 1 for clockwise, 0 for counter-clockwise</li>
</ul>
<p><strong>Warning:</strong> If current position doesn&#39;t match the calculated arc start point, a line segment (<code>L</code>) will be drawn to the arc start. For guaranteed continuous arcs, use <code>arcFromPolarOffset</code>.</p>
<pre><code>M 50 50
arcFromCenter(50, 0, 50, 180deg, 270deg, 1)
// Center at (100, 50), arc from (50, 50) to (100, 100)
</code></pre>
<h4>arcFromPolarOffset(angle, radius, angleOfArc)</h4>
<p>Draws an arc where the center is at a polar offset from current position. The current position is guaranteed to be on the circle, so only an <code>A</code> command is emitted (no <code>M</code> or <code>L</code>). Returns <code>{point, angle}</code> with endpoint and tangent.</p>
<ul>
<li><code>angle</code>: Direction from current position to arc center (radians)</li>
<li><code>radius</code>: Arc radius</li>
<li><code>angleOfArc</code>: Sweep angle (positive = clockwise, negative = counter-clockwise)</li>
</ul>
<p>This function is ideal for creating continuous curved paths because it never emits extra line segments.</p>
<pre><code>M 100 100
arcFromPolarOffset(0, 50, 90deg)
// Center at (150, 100), sweeps 90° clockwise
// Ends at (150, 50)
</code></pre>
<p><strong>Comparison with arcFromCenter:</strong></p>
<table>
<thead>
<tr>
<th>Aspect</th>
<th>arcFromCenter</th>
<th>arcFromPolarOffset</th>
</tr>
</thead>
<tbody><tr>
<td>Center defined by</td>
<td>Offset from current position</td>
<td>Polar direction from current position</td>
</tr>
<tr>
<td>Start point</td>
<td>Calculated from startAngle</td>
<td>Current position (guaranteed)</td>
</tr>
<tr>
<td>May emit L command</td>
<td>Yes, if position doesn&#39;t match</td>
<td>Never</td>
</tr>
<tr>
<td>Best for</td>
<td>Arcs with known center offset</td>
<td>Continuous curved paths</td>
</tr>
</tbody></table>
<h3>Tangent Functions</h3>
<p>These functions continue from the previous arc or polar command&#39;s direction.</p>
<h4>tangentLine(length)</h4>
<p>Draws a line continuing in the tangent direction from the previous arc or polar command.</p>
<pre><code>arcFromPolarOffset(0, 50, 90deg)
tangentLine(30)  // Continues in the arc&#39;s exit direction
</code></pre>
<h4>tangentArc(radius, sweepAngle)</h4>
<p>Draws an arc continuing tangent to the previous arc or polar command.</p>
<pre><code>arcFromPolarOffset(0, 50, 90deg)
tangentArc(30, 45deg)  // Smooth continuation with a smaller arc
</code></pre>
<hr>
<h2>Using Functions Inside calc()</h2>
<p>Math functions can be used inside <code>calc()</code>:</p>
<pre><code>M calc(sin(0.5) * 100) calc(cos(0.5) * 100)
L calc(lerp(0, 100, 0.5)) calc(clamp(150, 0, 100))
</code></pre>
<p>Path functions are called at the statement level:</p>
<pre><code>circle(100, 100, calc(25 + 25))  // calc() inside arguments
</code></pre>
`;

export const debug = `<h1>Debug &amp; Console</h1>
<p>The playground includes debugging tools to help you understand how your code executes and inspect values during evaluation.</p>
<h2>Console Output</h2>
<p>Click the <strong>Console</strong> button in the header to view debug output.</p>
<h2>log() Function</h2>
<p>Use <code>log()</code> to inspect values during execution:</p>
<pre><code>log(&quot;message&quot;)           // String message
log(myVar)               // Variable with label
log(&quot;pos:&quot;, ctx.position) // Multiple args
log(ctx)                 // Full context object
</code></pre>
<h3>Output Format</h3>
<p>String arguments display as-is. Other expressions show a label with the source:</p>
<pre><code>log(&quot;radius is&quot;, r)
// Output:
// radius is
// r = 50
</code></pre>
<p>Objects are expandable in the console - click the arrow to explore nested properties.</p>
<h2>ctx Object</h2>
<p>The <code>ctx</code> object tracks path state during evaluation:</p>
<h3>ctx.position</h3>
<p>Current pen position after the last command.</p>
<table>
<thead>
<tr>
<th>Property</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>ctx.position.x</code></td>
<td>X coordinate</td>
</tr>
<tr>
<td><code>ctx.position.y</code></td>
<td>Y coordinate</td>
</tr>
</tbody></table>
<pre><code>M 100 50
log(ctx.position)  // {x: 100, y: 50}
L 150 75
log(ctx.position)  // {x: 150, y: 75}
</code></pre>
<h3>ctx.start</h3>
<p>Subpath start position (set by <code>M</code>/<code>m</code>, used by <code>Z</code>).</p>
<table>
<thead>
<tr>
<th>Property</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>ctx.start.x</code></td>
<td>X coordinate</td>
</tr>
<tr>
<td><code>ctx.start.y</code></td>
<td>Y coordinate</td>
</tr>
</tbody></table>
<h3>ctx.commands</h3>
<p>Array of all executed commands with their positions:</p>
<pre><code>// Each entry contains:
{
  command: &quot;L&quot;,        // Command letter
  args: [150, 75],     // Evaluated arguments
  start: {x: 100, y: 50},
  end: {x: 150, y: 75}
}
</code></pre>
<h2>Using ctx in Paths</h2>
<p>Access position values with <code>calc()</code>:</p>
<pre><code>M 50 50
// Draw relative to current position
L calc(ctx.position.x + 30) ctx.position.y
circle(ctx.position.x, ctx.position.y, 5)
</code></pre>
<h2>Example: Debug a Loop</h2>
<pre><code>M 20 100
for (i in 0..4) {
  log(&quot;iteration&quot;, i, ctx.position)
  L calc(ctx.position.x + 40) 100
}
</code></pre>
<p>This logs the iteration number and current position at each step, helping you trace how the path is constructed.</p>
`;

export const cli = `<h1>CLI Reference</h1>
<p>The svg-path-extended CLI compiles extended SVG path syntax into standard SVG path strings or complete SVG files.</p>
<h2>Installation</h2>
<pre><code class="language-bash">npm install -g svg-path-extended
</code></pre>
<p>Or use with npx:</p>
<pre><code class="language-bash">npx svg-path-extended [options]
</code></pre>
<h2>Basic Usage</h2>
<h3>Compile a File</h3>
<pre><code class="language-bash">svg-path-extended input.svgx
</code></pre>
<p>Or with the explicit flag:</p>
<pre><code class="language-bash">svg-path-extended --src=input.svgx
</code></pre>
<h3>Compile Inline Code</h3>
<pre><code class="language-bash">svg-path-extended -e &#39;circle(100, 100, 50)&#39;
</code></pre>
<h3>Read from Stdin</h3>
<pre><code class="language-bash">echo &#39;let x = 50; circle(x, x, 25)&#39; | svg-path-extended -
</code></pre>
<pre><code class="language-bash">cat myfile.svgx | svg-path-extended -
</code></pre>
<h2>Output Options</h2>
<h3>Output Path Data to File</h3>
<pre><code class="language-bash">svg-path-extended --src=input.svgx -o output.txt
svg-path-extended --src=input.svgx --output output.txt
</code></pre>
<h3>Output as Complete SVG File</h3>
<p>Generate a complete SVG file with the path embedded:</p>
<pre><code class="language-bash">svg-path-extended --src=input.svgx --output-svg-file=output.svg
</code></pre>
<p>This creates a ready-to-use SVG file that can be opened in any browser or image viewer.</p>
<h2>Annotated Output</h2>
<p>Use <code>--annotated</code> to get a human-readable debug output that shows:</p>
<ul>
<li>Original comments preserved in place</li>
<li>Loop iterations with line numbers</li>
<li>Function call annotations with expanded output</li>
<li>Each path command on its own line</li>
</ul>
<p>This is useful for debugging complex path generation or understanding how your code produces its output.</p>
<h3>Basic Usage</h3>
<pre><code class="language-bash">svg-path-extended -e &#39;for (i in 0..3) { M i 0 }&#39; --annotated
</code></pre>
<p>Output:</p>
<pre><code>//--- for (i in 0..3) from line 1
  //--- iteration 0
  M 0 0
  //--- iteration 1
  M 1 0
  //--- iteration 2
  M 2 0
  //--- iteration 3
  M 3 0
</code></pre>
<h3>With Comments</h3>
<pre><code class="language-bash">svg-path-extended -e &#39;// Draw points
for (i in 0..3) { M i 0 }&#39; --annotated
</code></pre>
<p>Output:</p>
<pre><code>// Draw points

//--- for (i in 0..3) from line 2
  //--- iteration 0
  M 0 0
  //--- iteration 1
  M 1 0
  //--- iteration 2
  M 2 0
  //--- iteration 3
  M 3 0
</code></pre>
<h3>Loop Truncation</h3>
<p>Long loops (&gt;10 iterations) are automatically truncated to show the first 3 and last 3 iterations:</p>
<pre><code class="language-bash">svg-path-extended -e &#39;for (i in 0..100) { M i 0 }&#39; --annotated
</code></pre>
<p>Output:</p>
<pre><code>//--- for (i in 0..100) from line 1
  //--- iteration 0
  M 0 0
  //--- iteration 1
  M 1 0
  //--- iteration 2
  M 2 0
  ... 95 more iterations ...
  //--- iteration 98
  M 98 0
  //--- iteration 99
  M 99 0
  //--- iteration 100
  M 100 0
</code></pre>
<h3>Function Call Annotations</h3>
<p>Function calls show their name, arguments, and expanded output:</p>
<pre><code class="language-bash">svg-path-extended -e &#39;circle(50, 50, 25)&#39; --annotated
</code></pre>
<p>Output:</p>
<pre><code>//--- circle(50, 50, 25) called from line 1
  M 25 50
  A 25 25 0 1 1 75 50
  A 25 25 0 1 1 25 50
</code></pre>
<h3>Save to File</h3>
<pre><code class="language-bash">svg-path-extended --src=complex.svgx --annotated -o debug-output.txt
</code></pre>
<h2>SVG Styling Options</h2>
<p>When using <code>--output-svg-file</code>, you can customize the appearance:</p>
<table>
<thead>
<tr>
<th>Option</th>
<th>Default</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>--stroke=&lt;color&gt;</code></td>
<td><code>#000</code></td>
<td>Stroke color</td>
</tr>
<tr>
<td><code>--fill=&lt;color&gt;</code></td>
<td><code>none</code></td>
<td>Fill color</td>
</tr>
<tr>
<td><code>--stroke-width=&lt;n&gt;</code></td>
<td><code>2</code></td>
<td>Stroke width</td>
</tr>
<tr>
<td><code>--viewBox=&lt;box&gt;</code></td>
<td><code>0 0 200 200</code></td>
<td>SVG viewBox</td>
</tr>
<tr>
<td><code>--width=&lt;w&gt;</code></td>
<td><code>200</code></td>
<td>SVG width</td>
</tr>
<tr>
<td><code>--height=&lt;h&gt;</code></td>
<td><code>200</code></td>
<td>SVG height</td>
</tr>
</tbody></table>
<h3>Examples</h3>
<p>Red circle with no fill:</p>
<pre><code class="language-bash">svg-path-extended -e &#39;circle(100, 100, 50)&#39; \\
  --output-svg-file=circle.svg \\
  --stroke=red \\
  --stroke-width=3
</code></pre>
<p>Blue filled polygon:</p>
<pre><code class="language-bash">svg-path-extended -e &#39;polygon(100, 100, 80, 6)&#39; \\
  --output-svg-file=hexagon.svg \\
  --stroke=navy \\
  --fill=lightblue \\
  --stroke-width=2
</code></pre>
<p>Large canvas with custom viewBox:</p>
<pre><code class="language-bash">svg-path-extended --src=complex.svgx \\
  --output-svg-file=output.svg \\
  --viewBox=&quot;0 0 800 600&quot; \\
  --width=800 \\
  --height=600
</code></pre>
<h2>Help and Version</h2>
<pre><code class="language-bash">svg-path-extended --help
svg-path-extended -h

svg-path-extended --version
svg-path-extended -v
</code></pre>
<h2>Exit Codes</h2>
<table>
<thead>
<tr>
<th>Code</th>
<th>Meaning</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>Success</td>
</tr>
<tr>
<td>1</td>
<td>Error (parse error, file not found, etc.)</td>
</tr>
</tbody></table>
<h2>File Extensions</h2>
<p>By convention, source files use the <code>.svgx</code> extension, but any text file will work.</p>
<h2>Examples</h2>
<h3>Generate a Spiral</h3>
<pre><code class="language-bash">svg-path-extended -e &#39;
M 100 100
for (i in 1..50) {
  L calc(100 + cos(i * 0.3) * i * 1.5) calc(100 + sin(i * 0.3) * i * 1.5)
}
&#39; --output-svg-file=spiral.svg --stroke=teal --stroke-width=2
</code></pre>
<h3>Process Multiple Files</h3>
<pre><code class="language-bash">for file in examples/*.svgx; do
  svg-path-extended --src=&quot;$file&quot; --output-svg-file=&quot;\${file%.svgx}.svg&quot;
done
</code></pre>
<h3>Use in a Build Script</h3>
<pre><code class="language-json">{
  &quot;scripts&quot;: {
    &quot;build:icons&quot;: &quot;svg-path-extended --src=src/icons.svgx --output-svg-file=dist/icons.svg&quot;
  }
}
</code></pre>
`;

export const examples = `<h1>Examples</h1>
<p>Practical examples showing how to use svg-path-extended for common tasks.</p>
<h2>Basic Shapes</h2>
<h3>Simple Rectangle</h3>
<pre><code>rect(10, 10, 180, 80)
</code></pre>
<h3>Circle</h3>
<pre><code>circle(100, 100, 50)
</code></pre>
<h3>Rounded Rectangle</h3>
<pre><code>roundRect(20, 40, 160, 120, 15)
</code></pre>
<h2>Using Variables</h2>
<h3>Centered Circle</h3>
<pre><code>let width = 200;
let height = 200;
let cx = calc(width / 2);
let cy = calc(height / 2);
let r = 40;

circle(cx, cy, r)
</code></pre>
<h3>Configurable Star</h3>
<pre><code>let centerX = 100;
let centerY = 100;
let outerR = 60;
let innerR = 25;
let points = 5;

star(centerX, centerY, outerR, innerR, points)
</code></pre>
<h2>Loops and Patterns</h2>
<h3>Row of Circles</h3>
<pre><code>for (i in 0..5) {
  circle(calc(30 + i * 35), 100, 15)
}
</code></pre>
<h3>Grid of Dots</h3>
<pre><code>for (row in 0..5) {
  for (col in 0..5) {
    circle(calc(20 + col * 40), calc(20 + row * 40), 5)
  }
}
</code></pre>
<h3>Concentric Circles</h3>
<pre><code>let cx = 100;
let cy = 100;

for (i in 1..6) {
  circle(cx, cy, calc(i * 15))
}
</code></pre>
<h2>Trigonometry</h2>
<h3>Points on a Circle</h3>
<pre><code>let cx = 100;
let cy = 100;
let r = 60;
let points = 8;

for (i in 0..points) {
  let angle = calc(i / points * TAU());
  let x = calc(cx + cos(angle) * r);
  let y = calc(cy + sin(angle) * r);
  circle(x, y, 5)
}
</code></pre>
<h3>Spiral</h3>
<pre><code>M 100 100
for (i in 1..100) {
  let angle = calc(i * 0.2);
  let r = calc(i * 0.8);
  L calc(100 + cos(angle) * r) calc(100 + sin(angle) * r)
}
</code></pre>
<h3>Sine Wave</h3>
<pre><code>M 0 100
for (i in 1..40) {
  let x = calc(i * 5);
  let y = calc(100 + sin(i * 0.3) * 30);
  L x y
}
</code></pre>
<h3>Flower Pattern</h3>
<pre><code>let cx = 100;
let cy = 100;
let petalCount = 6;
let petalRadius = 25;
let centerRadius = 15;

// Petals
for (i in 0..petalCount) {
  let angle = calc(i / petalCount * TAU());
  let px = calc(cx + cos(angle) * 35);
  let py = calc(cy + sin(angle) * 35);
  circle(px, py, petalRadius)
}

// Center
circle(cx, cy, centerRadius)
</code></pre>
<h2>Custom Functions</h2>
<h3>Reusable Square</h3>
<pre><code>fn square(x, y, size) {
  rect(x, y, size, size)
}

square(10, 10, 50)
square(70, 10, 50)
square(130, 10, 50)
</code></pre>
<h3>Diamond Shape</h3>
<pre><code>fn diamond(cx, cy, size) {
  M cx calc(cy - size)
  L calc(cx + size) cy
  L cx calc(cy + size)
  L calc(cx - size) cy
  Z
}

diamond(100, 100, 40)
</code></pre>
<h3>Arrow</h3>
<pre><code>fn arrow(x1, y1, x2, y2, headSize) {
  // Line
  M x1 y1
  L x2 y2

  // Arrowhead (simplified)
  let angle = atan2(calc(y2 - y1), calc(x2 - x1));
  let a1 = calc(angle + 2.5);
  let a2 = calc(angle - 2.5);

  M x2 y2
  L calc(x2 - cos(a1) * headSize) calc(y2 - sin(a1) * headSize)
  M x2 y2
  L calc(x2 - cos(a2) * headSize) calc(y2 - sin(a2) * headSize)
}

arrow(20, 100, 180, 100, 15)
</code></pre>
<h2>Conditionals</h2>
<h3>Size-Based Shape</h3>
<pre><code>let size = 80;

if (size &gt; 50) {
  circle(100, 100, size)
} else {
  rect(calc(100 - size / 2), calc(100 - size / 2), size, size)
}
</code></pre>
<h3>Alternating Pattern</h3>
<pre><code>for (i in 0..10) {
  let x = calc(20 + i * 18);
  if (calc(i % 2) == 0) {
    circle(x, 100, 8)
  } else {
    rect(calc(x - 6), 94, 12, 12)
  }
}
</code></pre>
<h2>Complex Examples</h2>
<h3>Gear Shape</h3>
<pre><code>let cx = 100;
let cy = 100;
let innerR = 30;
let outerR = 50;
let teeth = 12;

M calc(cx + outerR) cy

for (i in 0..teeth) {
  let a1 = calc(i / teeth * TAU());
  let a2 = calc((i + 0.3) / teeth * TAU());
  let a3 = calc((i + 0.5) / teeth * TAU());
  let a4 = calc((i + 0.8) / teeth * TAU());

  L calc(cx + cos(a1) * outerR) calc(cy + sin(a1) * outerR)
  L calc(cx + cos(a2) * outerR) calc(cy + sin(a2) * outerR)
  L calc(cx + cos(a3) * innerR) calc(cy + sin(a3) * innerR)
  L calc(cx + cos(a4) * innerR) calc(cy + sin(a4) * innerR)
}

Z

// Center hole
circle(cx, cy, 10)
</code></pre>
<h3>Recursive-Style Tree (using loops)</h3>
<pre><code>// Simple branching pattern
fn branch(x, y, length, angle, depth) {
  let x2 = calc(x + cos(angle) * length);
  let y2 = calc(y + sin(angle) * length);
  M x y
  L x2 y2
}

let startX = 100;
let startY = 180;

// Trunk
M startX startY
L startX 120

// Main branches
for (i in 0..5) {
  let angle = calc(-1.57 + (i - 2) * 0.4);
  let len = calc(30 - abs(i - 2) * 5);
  branch(startX, 120, len, angle, 0)
}
</code></pre>
<h2>Tips</h2>
<ol>
<li><strong>Start simple</strong>: Build complex shapes from simple parts</li>
<li><strong>Use variables</strong>: Makes code readable and adjustable</li>
<li><strong>Extract functions</strong>: Reuse common patterns</li>
<li><strong>Test incrementally</strong>: Generate SVGs often to see results</li>
<li><strong>Use comments</strong>: Document your intent for complex sections</li>
</ol>
`;

// All available documentation sections
export const sections = {
  gettingStarted,
  syntax,
  stdlib,
  debug,
  cli,
  examples,
};
