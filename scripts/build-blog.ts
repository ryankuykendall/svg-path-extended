import { Command } from 'commander';
import { promises as fs } from 'fs';
import { join, dirname } from 'path';
import { fileURLToPath } from 'url';
import { marked } from 'marked';
import { markedHighlight } from 'marked-highlight';
import hljs from 'highlight.js/lib/core';

// Register languages we need
import javascript from 'highlight.js/lib/languages/javascript';
import bash from 'highlight.js/lib/languages/bash';
import json from 'highlight.js/lib/languages/json';
import xml from 'highlight.js/lib/languages/xml';

hljs.registerLanguage('javascript', javascript);
hljs.registerLanguage('js', javascript);
hljs.registerLanguage('bash', bash);
hljs.registerLanguage('shell', bash);
hljs.registerLanguage('json', json);
hljs.registerLanguage('html', xml);
hljs.registerLanguage('xml', xml);
hljs.registerLanguage('toml', bash); // Close enough for toml highlighting

const __dirname = dirname(fileURLToPath(import.meta.url));
const ROOT = join(__dirname, '..');
const BLOG_DIR = join(ROOT, 'website', 'blog');
const OUTPUT_FILE = join(ROOT, 'playground', 'utils', 'blog-content.js');

// Configure marked with syntax highlighting
marked.use(
  markedHighlight({
    emptyLangClass: 'hljs',
    langPrefix: 'hljs language-',
    highlight(code: string, lang: string) {
      if (lang && hljs.getLanguage(lang)) {
        return hljs.highlight(code, { language: lang, ignoreIllegals: true }).value;
      }
      return hljs.highlightAuto(code).value;
    }
  })
);

marked.setOptions({
  gfm: true,
  breaks: false,
});

interface Frontmatter {
  title?: string;
  slug?: string;
  date?: string;
  description?: string;
  [key: string]: string | undefined;
}

/**
 * Parse YAML frontmatter from markdown content
 * Returns { frontmatter, content } where frontmatter is an object
 */
function parseFrontmatter(markdown: string): { frontmatter: Frontmatter; content: string } {
  const frontmatterRegex = /^---\n([\s\S]*?)\n---\n/;
  const match = markdown.match(frontmatterRegex);

  if (!match) {
    return { frontmatter: {}, content: markdown };
  }

  const frontmatterText = match[1];
  const content = markdown.slice(match[0].length);

  // Simple YAML parser for our frontmatter format
  const frontmatter: Frontmatter = {};
  const lines = frontmatterText.split('\n');

  for (const line of lines) {
    const colonIndex = line.indexOf(':');
    if (colonIndex === -1) continue;

    const key = line.slice(0, colonIndex).trim();
    let value = line.slice(colonIndex + 1).trim();

    // Remove surrounding quotes
    if ((value.startsWith('"') && value.endsWith('"')) ||
        (value.startsWith("'") && value.endsWith("'"))) {
      value = value.slice(1, -1);
    }

    frontmatter[key] = value;
  }

  return { frontmatter, content };
}

interface BlogEntry {
  slug: string;
  title: string;
  date: string;
  description: string;
}

async function buildBlog(): Promise<void> {
  console.log('Building blog...\n');

  // Check if blog directory exists
  try {
    await fs.access(BLOG_DIR);
  } catch {
    console.log('No blog directory found. Creating empty blog-content.js...');
    await fs.writeFile(OUTPUT_FILE, `// Auto-generated by scripts/build-blog.ts
// No blog posts found

export const blogIndex = [];
export const posts = {};
`);
    return;
  }

  // Read all markdown files
  const files = await fs.readdir(BLOG_DIR);
  const mdFiles = files.filter(f => f.endsWith('.md'));

  if (mdFiles.length === 0) {
    console.log('No markdown files found in website/blog/');
    await fs.writeFile(OUTPUT_FILE, `// Auto-generated by scripts/build-blog.ts
// No blog posts found

export const blogIndex = [];
export const posts = {};
`);
    return;
  }

  const blogIndex: BlogEntry[] = [];
  const posts: Record<string, string> = {};

  for (const filename of mdFiles) {
    const filepath = join(BLOG_DIR, filename);
    const markdown = await fs.readFile(filepath, 'utf-8');

    const { frontmatter, content } = parseFrontmatter(markdown);

    // Validate required frontmatter
    if (!frontmatter.title || !frontmatter.slug || !frontmatter.date) {
      console.log(`  ✗ ${filename} (missing required frontmatter: title, slug, date)`);
      continue;
    }

    const html = marked.parse(content) as string;

    blogIndex.push({
      slug: frontmatter.slug,
      title: frontmatter.title,
      date: frontmatter.date,
      description: frontmatter.description || ''
    });

    posts[frontmatter.slug] = html;

    console.log(`  ✓ ${filename} → ${frontmatter.slug}`);
  }

  // Sort by date (newest first)
  blogIndex.sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime());

  // Generate the JavaScript module
  const escapeForTemplate = (str: string): string => str
    .replace(/\\/g, '\\\\')
    .replace(/`/g, '\\`')
    .replace(/\$\{/g, '\\${');

  let output = `// Auto-generated by scripts/build-blog.ts
// Do not edit manually - edit the markdown files in /website/blog/ instead

export const blogIndex = ${JSON.stringify(blogIndex, null, 2)};

export const posts = {
`;

  for (const [slug, html] of Object.entries(posts)) {
    output += `  '${slug}': \`${escapeForTemplate(html)}\`,\n`;
  }

  output += `};
`;

  await fs.writeFile(OUTPUT_FILE, output);

  console.log(`\nGenerated: playground/utils/blog-content.js`);
  console.log(`Posts: ${blogIndex.length}`);
}

const program = new Command();
program
  .name('build-blog')
  .description('Convert blog markdown posts to a JavaScript module')
  .action(async () => {
    try {
      await buildBlog();
    } catch (err) {
      console.error('Build failed:', err);
      process.exit(1);
    }
  });
program.parse();
